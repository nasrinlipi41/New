import sqlite3
import logging
import asyncio
import random
import hashlib
import threading
from typing import Dict, List, Tuple
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    filters,
    PicklePersistence,
)
from telegram.constants import ParseMode
from contextlib import contextmanager

# ==================== CONFIGURATION ====================
BOT_TOKEN = '8520054544:AAE_fT379ilqkYBtnH8L7B4JsITpWegJfu4'
ADMIN_IDS = [5487394544]
DB_NAME = 'stylish_name_bot.db'
ITEMS_PER_PAGE = 10
MAX_NAME_LENGTH = 30

# ==================== LOGGING ====================
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ==================== DATABASE LOCK ====================
db_lock = threading.Lock()

@contextmanager
def get_db_connection():
    """Thread-safe database connection"""
    with db_lock:
        conn = sqlite3.connect(DB_NAME, check_same_thread=False, timeout=10)
        conn.row_factory = sqlite3.Row
        try:
            yield conn
        finally:
            conn.close()

# ==================== DATABASE ====================
class Database:
    @staticmethod
    def setup():
        """Initialize database"""
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                
                # Create tables with correct schema
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS users (
                        user_id INTEGER PRIMARY KEY,
                        first_name TEXT,
                        username TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                cursor.execute('''
                    CREATE TABLE IF NOT EXISTS generated_styles (
                        id INTEGER PRIMARY KEY AUTOINCREMENT,
                        user_id INTEGER,
                        original_text TEXT,
                        styled_text TEXT,
                        style_type TEXT,
                        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                    )
                ''')
                
                conn.commit()
                logger.info("‚úÖ Database initialized")
                
        except sqlite3.Error as e:
            logger.error(f"Database error: {e}")
    
    @staticmethod
    def add_user(user_id: int, first_name: str, username: str):
        """Add user to database"""
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT OR REPLACE INTO users (user_id, first_name, username) 
                    VALUES (?, ?, ?)
                ''', (user_id, first_name, username or ""))
                conn.commit()
        except sqlite3.Error as e:
            logger.error(f"Add user error: {e}")
    
    @staticmethod
    def get_user_count():
        """Get total user count"""
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT COUNT(*) FROM users")
                count = cursor.fetchone()[0]
                return count if count else 0
        except sqlite3.Error as e:
            logger.error(f"Get user count error: {e}")
            return 0
    
    @staticmethod
    def get_all_users():
        """Get all user IDs"""
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                cursor.execute("SELECT user_id FROM users")
                return [row[0] for row in cursor.fetchall()]
        except sqlite3.Error as e:
            logger.error(f"Get all users error: {e}")
            return []
    
    @staticmethod
    def save_style(user_id: int, original: str, styled: str, style_type: str):
        """Save generated style"""
        try:
            with get_db_connection() as conn:
                cursor = conn.cursor()
                cursor.execute('''
                    INSERT INTO generated_styles (user_id, original_text, styled_text, style_type)
                    VALUES (?, ?, ?, ?)
                ''', (user_id, original, styled, style_type))
                conn.commit()
        except sqlite3.Error as e:
            logger.error(f"Save style error: {e}")

# ==================== FONTS & STYLES ====================
class FontStyles:
    # Base characters for translation
    NORMAL = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    
    # 50+ Fonts Collection
    FONTS = {
        'bold': "ùóÆùóØùó∞ùó±ùó≤ùó≥ùó¥ùóµùó∂ùó∑ùó∏ùóπùó∫ùóªùóºùóΩùóæùóøùòÄùòÅùòÇùòÉùòÑùòÖùòÜùòáùóîùóïùóñùóóùóòùóôùóöùóõùóúùóùùóûùóüùó†ùó°ùó¢ùó£ùó§ùó•ùó¶ùóßùó®ùó©ùó™ùó´ùó¨ùó≠ùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüµ",
        'italic': "ùò¢ùò£ùò§ùò•ùò¶ùòßùò®ùò©ùò™ùò´ùò¨ùò≠ùòÆùòØùò∞ùò±ùò≤ùò≥ùò¥ùòµùò∂ùò∑ùò∏ùòπùò∫ùòªùòàùòâùòäùòãùòåùòçùòéùòèùòêùòëùòíùòìùòîùòïùòñùòóùòòùòôùòöùòõùòúùòùùòûùòüùöàùöâ0123456789",
        'bold_italic': "ùôñùôóùôòùôôùôöùôõùôúùôùùôûùôüùô†ùô°ùô¢ùô£ùô§ùô•ùô¶ùôßùô®ùô©ùô™ùô´ùô¨ùô≠ùôÆùôØùòºùòΩùòæùòøùôÄùôÅùôÇùôÉùôÑùôÖùôÜùôáùôàùôâùôäùôãùôåùôçùôéùôèùôêùôëùôíùôìùôîùôïùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüø",
        'monospace': "ùöäùöãùöåùöçùöéùöèùöêùöëùöíùöìùöîùöïùöñùöóùöòùöôùööùöõùöúùöùùöûùöüùö†ùö°ùö¢ùö£ùô∞ùô±ùô≤ùô≥ùô¥ùôµùô∂ùô∑ùô∏ùôπùô∫ùôªùôºùôΩùôæùôøùöÄùöÅùöÇùöÉùöÑùöÖùöÜùöáùöàùöâùü∂ùü∑ùü∏ùüπùü∫ùüªùüºùüΩùüæùüø",
        'cursive': "ùí∂ùí∑ùí∏ùíπùëíùíªùëîùíΩùíæùíøùìÄùìÅùìÇùìÉùëúùìÖùìÜùìáùìàùìâùìäùìãùìåùìçùìéùìèùíúùêµùíûùíüùê∏ùêπùí¢ùêªùêºùí•ùí¶ùêøùëÄùí©ùí™ùí´ùí¨ùëÖùíÆùíØùí∞ùí±ùí≤ùí≥ùí¥ùíµùü¢ùü£ùü§ùü•ùü¶ùüßùü®ùü©ùü™ùü´",
        'fraktur': "ùîûùîüùî†ùî°ùî¢ùî£ùî§ùî•ùî¶ùîßùî®ùî©ùî™ùî´ùî¨ùî≠ùîÆùîØùî∞ùî±ùî≤ùî≥ùî¥ùîµùî∂ùî∑ùîÑùîÖ‚Ñ≠ùîáùîàùîâùîä‚Ñå‚Ñëùîçùîéùîèùîêùîëùîíùîìùîî‚Ñúùîñùîóùîòùîôùîöùîõùîú‚Ñ®0123456789",
        'blackboard': "ùïíùïìùïîùïïùïñùïóùïòùïôùïöùïõùïúùïùùïûùïüùï†ùï°ùï¢ùï£ùï§ùï•ùï¶ùïßùï®ùï©ùï™ùï´ùî∏ùîπ‚ÑÇùîªùîºùîΩùîæ‚ÑçùïÄùïÅùïÇùïÉùïÑ‚ÑïùïÜ‚Ñô‚Ñö‚Ñùùïäùïãùïåùïçùïéùïèùïê‚Ñ§ùüòùüôùüöùüõùüúùüùùüûùüüùü†ùü°",
        'small_caps': "·¥Ä ô·¥Ñ·¥Ö·¥á“ì…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ Äs·¥õ·¥ú·¥†·¥°x è·¥¢ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
        'bubble': "‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè‚ì™‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®",
        'circled': "‚ìê‚ìë‚ìí‚ìì‚ìî‚ìï‚ìñ‚ìó‚ìò‚ìô‚ìö‚ìõ‚ìú‚ìù‚ìû‚ìü‚ì†‚ì°‚ì¢‚ì£‚ì§‚ì•‚ì¶‚ìß‚ì®‚ì©‚í∂‚í∑‚í∏‚íπ‚í∫‚íª‚íº‚íΩ‚íæ‚íø‚ìÄ‚ìÅ‚ìÇ‚ìÉ‚ìÑ‚ìÖ‚ìÜ‚ìá‚ìà‚ìâ‚ìä‚ìã‚ìå‚ìç‚ìé‚ìè‚ì™‚ë†‚ë°‚ë¢‚ë£‚ë§‚ë•‚ë¶‚ëß‚ë®",
        'square': "üÑ∞üÑ±üÑ≤üÑ≥üÑ¥üÑµüÑ∂üÑ∑üÑ∏üÑπüÑ∫üÑªüÑºüÑΩüÑæüÑøüÖÄüÖÅüÖÇüÖÉüÖÑüÖÖüÖÜüÖáüÖàüÖâ0123456789",
        'gothic': "ùîÑùîÖ‚Ñ≠ùîáùîàùîâùîä‚Ñå‚Ñëùîçùîéùîèùîêùîëùîíùîìùîî‚Ñúùîñùîóùîòùîôùîöùîõùîú‚Ñ®ùîûùîüùî†ùî°ùî¢ùî£ùî§ùî•ùî¶ùîßùî®ùî©ùî™ùî´ùî¨ùî≠ùîÆùîØùî∞ùî±ùî≤ùî≥ùî¥ùîµùî∂ùî∑0123456789",
        'double_struck': "ùî∏ùîπ‚ÑÇùîªùîºùîΩùîæ‚ÑçùïÄùïÅùïÇùïÉùïÑ‚ÑïùïÜ‚Ñô‚Ñö‚Ñùùïäùïãùïåùïçùïéùïèùïê‚Ñ§ùïíùïìùïîùïïùïñùïóùïòùïôùïöùïõùïúùïùùïûùïüùï†ùï°ùï¢ùï£ùï§ùï•ùï¶ùïßùï®ùï©ùï™ùï´ùüòùüôùüöùüõùüúùüùùüûùüüùü†ùü°",
        'script': "ùíúùêµùíûùíüùê∏ùêπùí¢ùêªùêºùí•ùí¶ùêøùëÄùí©ùí™ùí´ùí¨ùëÖùíÆùíØùí∞ùí±ùí≤ùí≥ùí¥ùíµùí∂ùí∑ùí∏ùíπùëíùíªùëîùíΩùíæùíøùìÄùìÅùìÇùìÉùëúùìÖùìÜùìáùìàùìâùìäùìãùìåùìçùìéùìè0123456789",
        'superscript': "·µÉ·µá·∂ú·µà·µâ·∂†·µç ∞‚Å± ≤·µèÀ°·µê‚Åø·µí·µñ·µ† ≥À¢·µó·µò·µõ ∑À£ ∏·∂ª·¥¨·¥Æ·∂ú·¥∞·¥±·∂†·¥≥·¥¥·¥µ·¥∂·¥∑·¥∏·¥π·¥∫·¥º·¥æ·µ†·¥øÀ¢·µÄ·µÅ‚±Ω·µÇÀ£ ∏·∂ª‚Å∞¬π¬≤¬≥‚Å¥‚Åµ‚Å∂‚Å∑‚Å∏‚Åπ",
        'subscript': "‚Çê‚Çë‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚Çö·µ£‚Çõ‚Çú·µ§·µ•‚Çì·µßùìè‚Çêùì´ùí∏ùíπ‚Çëùíªùì∞‚Çï·µ¢‚±º‚Çñ‚Çó‚Çò‚Çô‚Çí‚ÇöùìÜ·µ£‚Çõ‚Çú·µ§·µ•ùìå‚Çì·µßùìè‚ÇÄ‚ÇÅ‚ÇÇ‚ÇÉ‚ÇÑ‚ÇÖ‚ÇÜ‚Çá‚Çà‚Çâ",
        'outline': "ùï¨ùï≠ùïÆùïØùï∞ùï±ùï≤ùï≥ùï¥ùïµùï∂ùï∑ùï∏ùïπùï∫ùïªùïºùïΩùïæùïøùñÄùñÅùñÇùñÉùñÑùñÖùñÜùñáùñàùñâùñäùñãùñåùñçùñéùñèùñêùñëùñíùñìùñîùñïùññùñóùñòùñôùñöùñõùñúùñùùñûùñü0123456789",
        'heavy': "ùóîùóïùóñùóóùóòùóôùóöùóõùóúùóùùóûùóüùó†ùó°ùó¢ùó£ùó§ùó•ùó¶ùóßùó®ùó©ùó™ùó´ùó¨ùó≠ùóÆùóØùó∞ùó±ùó≤ùó≥ùó¥ùóµùó∂ùó∑ùó∏ùóπùó∫ùóªùóºùóΩùóæùóøùòÄùòÅùòÇùòÉùòÑùòÖùòÜùòáùü¨ùü≠ùüÆùüØùü∞ùü±ùü≤ùü≥ùü¥ùüµ",
        'wide': "ÔΩÅÔΩÇÔΩÉÔΩÑÔΩÖÔΩÜÔΩáÔΩàÔΩâÔΩäÔΩãÔΩåÔΩçÔΩéÔΩèÔΩêÔΩëÔΩíÔΩìÔΩîÔΩïÔΩñÔΩóÔΩòÔΩôÔΩöÔº°Ôº¢Ôº£Ôº§Ôº•Ôº¶ÔºßÔº®Ôº©Ôº™Ôº´Ôº¨Ôº≠ÔºÆÔºØÔº∞Ôº±Ôº≤Ôº≥Ôº¥ÔºµÔº∂Ôº∑Ôº∏ÔºπÔº∫ÔºêÔºëÔºíÔºìÔºîÔºïÔºñÔºóÔºòÔºô",
        'narrow': "·¥Ä ô·¥Ñ·¥Ö·¥áÍú∞…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ ÄÍú±·¥õ·¥ú·¥†·¥°x è·¥¢·¥Ä ô·¥Ñ·¥Ö·¥áÍú∞…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ ÄÍú±·¥õ·¥ú·¥†·¥°x è·¥¢0123456789",
        'upside_down': "…êq…îp«ù…ü∆É…•ƒ±…æ ûl…Øuodb…πs án å çx éz‚àÄq∆Üp∆é‚Ñ≤◊§HI≈ø ûÀ•WNO‘ÄQ…πS‚î¥‚à©ŒõMX‚ÖÑZ0∆ñ·ÑÖ∆ê„Ñ£œõ9„Ñ•86",
        'mirror': "…êq…îp«ù…ü∆É…•ƒ±…æ ûl…Øuodb…πs án å çx éz‚àÄq∆Üp∆é‚Ñ≤◊§HI≈ø ûÀ•WNO‘ÄQ…πS‚î¥‚à©ŒõMX‚ÖÑZ0∆ñ·ÑÖ∆ê„Ñ£œõ9„Ñ•86",
        'strikethrough': "aÃ∂bÃ∂cÃ∂dÃ∂eÃ∂fÃ∂gÃ∂hÃ∂iÃ∂jÃ∂kÃ∂lÃ∂mÃ∂nÃ∂oÃ∂pÃ∂qÃ∂rÃ∂sÃ∂tÃ∂uÃ∂vÃ∂wÃ∂xÃ∂yÃ∂zÃ∂AÃ∂BÃ∂CÃ∂DÃ∂EÃ∂FÃ∂GÃ∂HÃ∂IÃ∂JÃ∂KÃ∂LÃ∂MÃ∂NÃ∂OÃ∂PÃ∂QÃ∂RÃ∂SÃ∂TÃ∂UÃ∂VÃ∂WÃ∂XÃ∂YÃ∂ZÃ∂0Ã∂1Ã∂2Ã∂3Ã∂4Ã∂5Ã∂6Ã∂7Ã∂8Ã∂9Ã∂",
        'underline': "aÃ≤bÃ≤cÃ≤dÃ≤eÃ≤fÃ≤gÃ≤hÃ≤iÃ≤jÃ≤kÃ≤lÃ≤mÃ≤nÃ≤oÃ≤pÃ≤qÃ≤rÃ≤sÃ≤tÃ≤uÃ≤vÃ≤wÃ≤xÃ≤yÃ≤zÃ≤AÃ≤BÃ≤CÃ≤DÃ≤EÃ≤FÃ≤GÃ≤HÃ≤IÃ≤JÃ≤KÃ≤LÃ≤MÃ≤NÃ≤OÃ≤PÃ≤QÃ≤RÃ≤SÃ≤TÃ≤UÃ≤VÃ≤WÃ≤XÃ≤YÃ≤ZÃ≤0Ã≤1Ã≤2Ã≤3Ã≤4Ã≤5Ã≤6Ã≤7Ã≤8Ã≤9Ã≤",
        'overline': "aÃÖbÃÖcÃÖdÃÖeÃÖfÃÖgÃÖhÃÖiÃÖjÃÖkÃÖlÃÖmÃÖnÃÖoÃÖpÃÖqÃÖrÃÖsÃÖtÃÖuÃÖvÃÖwÃÖxÃÖyÃÖzÃÖAÃÖBÃÖCÃÖDÃÖEÃÖFÃÖGÃÖHÃÖIÃÖJÃÖKÃÖLÃÖMÃÖNÃÖOÃÖPÃÖQÃÖRÃÖSÃÖTÃÖUÃÖVÃÖWÃÖXÃÖYÃÖZÃÖ0ÃÖ1ÃÖ2ÃÖ3ÃÖ4ÃÖ5ÃÖ6ÃÖ7ÃÖ8ÃÖ9ÃÖ",
        'double_underline': "aÃ≥bÃ≥cÃ≥dÃ≥eÃ≥fÃ≥gÃ≥hÃ≥iÃ≥jÃ≥kÃ≥lÃ≥mÃ≥nÃ≥oÃ≥pÃ≥qÃ≥rÃ≥sÃ≥tÃ≥uÃ≥vÃ≥wÃ≥xÃ≥yÃ≥zÃ≥AÃ≥BÃ≥CÃ≥DÃ≥EÃ≥FÃ≥GÃ≥HÃ≥IÃ≥JÃ≥KÃ≥LÃ≥MÃ≥NÃ≥OÃ≥PÃ≥QÃ≥RÃ≥SÃ≥TÃ≥UÃ≥VÃ≥WÃ≥XÃ≥YÃ≥ZÃ≥0Ã≥1Ã≥2Ã≥3Ã≥4Ã≥5Ã≥6Ã≥7Ã≥8Ã≥9Ã≥",
        'squiggle': "aÃ∞bÃ∞cÃ∞dÃ∞eÃ∞fÃ∞gÃ∞hÃ∞iÃ∞jÃ∞kÃ∞lÃ∞mÃ∞nÃ∞oÃ∞pÃ∞qÃ∞rÃ∞sÃ∞tÃ∞uÃ∞vÃ∞wÃ∞xÃ∞yÃ∞zÃ∞AÃ∞BÃ∞CÃ∞DÃ∞EÃ∞FÃ∞GÃ∞HÃ∞IÃ∞JÃ∞KÃ∞LÃ∞MÃ∞NÃ∞OÃ∞PÃ∞QÃ∞RÃ∞SÃ∞TÃ∞UÃ∞VÃ∞WÃ∞XÃ∞YÃ∞ZÃ∞0Ã∞1Ã∞2Ã∞3Ã∞4Ã∞5Ã∞6Ã∞7Ã∞8Ã∞9Ã∞",
        'wave': "aÃÉbÃÉcÃÉdÃÉeÃÉfÃÉgÃÉhÃÉiÃÉjÃÉkÃÉlÃÉmÃÉnÃÉoÃÉpÃÉqÃÉrÃÉsÃÉtÃÉuÃÉvÃÉwÃÉxÃÉyÃÉzÃÉAÃÉBÃÉCÃÉDÃÉEÃÉFÃÉGÃÉHÃÉIÃÉJÃÉKÃÉLÃÉMÃÉNÃÉOÃÉPÃÉQÃÉRÃÉSÃÉTÃÉUÃÉVÃÉWÃÉXÃÉYÃÉZÃÉ0ÃÉ1ÃÉ2ÃÉ3ÃÉ4ÃÉ5ÃÉ6ÃÉ7ÃÉ8ÃÉ9ÃÉ",
        'slash': "aÃ∑bÃ∑cÃ∑dÃ∑eÃ∑fÃ∑gÃ∑hÃ∑iÃ∑jÃ∑kÃ∑lÃ∑mÃ∑nÃ∑oÃ∑pÃ∑qÃ∑rÃ∑sÃ∑tÃ∑uÃ∑vÃ∑wÃ∑xÃ∑yÃ∑zÃ∑AÃ∑BÃ∑CÃ∑DÃ∑EÃ∑FÃ∑GÃ∑HÃ∑IÃ∑JÃ∑KÃ∑LÃ∑MÃ∑NÃ∑OÃ∑PÃ∑QÃ∑RÃ∑SÃ∑TÃ∑UÃ∑VÃ∑WÃ∑XÃ∑YÃ∑ZÃ∑0Ã∑1Ã∑2Ã∑3Ã∑4Ã∑5Ã∑6Ã∑7Ã∑8Ã∑9Ã∑",
        'x_through': "aÃ∏bÃ∏cÃ∏dÃ∏eÃ∏fÃ∏gÃ∏hÃ∏iÃ∏jÃ∏kÃ∏lÃ∏mÃ∏nÃ∏oÃ∏pÃ∏qÃ∏rÃ∏sÃ∏tÃ∏uÃ∏vÃ∏wÃ∏xÃ∏yÃ∏zÃ∏AÃ∏BÃ∏CÃ∏DÃ∏EÃ∏FÃ∏GÃ∏HÃ∏IÃ∏JÃ∏KÃ∏LÃ∏MÃ∏NÃ∏OÃ∏PÃ∏QÃ∏RÃ∏SÃ∏TÃ∏UÃ∏VÃ∑WÃ∑XÃ∑YÃ∑ZÃ∑0Ã∑1Ã∑2Ã∑3Ã∑4Ã∑5Ã∑6Ã∑7Ã∑8Ã∑9Ã∑",
        'asterisk': "aÕôbÕôcÕôdÕôeÕôfÕôgÕôhÕôiÕôjÕôkÕôlÕômÕônÕôoÕôpÕôqÕôrÕôsÕôtÕôuÕôvÕôwÕôxÕôyÕôzÕôAÕôBÕôCÕôDÕôEÕôFÕôGÕôHÕôIÕôJÕôKÕôLÕôMÕôNÕôOÕôPÕôQÕôRÕôSÕôTÕôUÕôVÕôWÕôXÕôYÕôZÕô0Õô1Õô2Õô3Õô4Õô5Õô6Õô7Õô8Õô9Õô",
        'dot_above': "aÃábÃácÃádÃáeÃáfÃágÃáhÃáiÃájÃákÃálÃámÃánÃáoÃápÃáqÃárÃásÃátÃáuÃávÃáwÃáxÃáyÃázÃáAÃáBÃáCÃáDÃáEÃáFÃáGÃáHÃáIÃáJÃáKÃáLÃáMÃáNÃáOÃáPÃáQÃáRÃáSÃáTÃáUÃáVÃáWÃáXÃáYÃáZÃá0Ãá1Ãá2Ãá3Ãá4Ãá5Ãá6Ãá7Ãá8Ãá9Ãá",
        'dot_below': "aÃ£bÃ£cÃ£dÃ£eÃ£fÃ£gÃ£hÃ£iÃ£jÃ£kÃ£lÃ£mÃ£nÃ£oÃ£pÃ£qÃ£rÃ£sÃ£tÃ£uÃ£vÃ£wÃ£xÃ£yÃ£zÃ£AÃ£BÃ£CÃ£DÃ£EÃ£FÃ£GÃ£HÃ£IÃ£JÃ£KÃ£LÃ£MÃ£NÃ£OÃ£PÃ£QÃ£RÃ£SÃ£TÃ£UÃ£VÃ£WÃ£XÃ£YÃ£ZÃ£0Ã£1Ã£2Ã£3Ã£4Ã£5Ã£6Ã£7Ã£8Ã£9Ã£",
        'ring_above': "aÃäbÃäcÃädÃäeÃäfÃägÃähÃäiÃäjÃäkÃälÃämÃänÃäoÃäpÃäqÃärÃäsÃätÃäuÃävÃäwÃäxÃäyÃäzÃäAÃäBÃäCÃäDÃäEÃäFÃäGÃäHÃäIÃäJÃäKÃäLÃäMÃäNÃäOÃäPÃäQÃäRÃäSÃäTÃäUÃäVÃäWÃäXÃäYÃäZÃä0Ãä1Ãä2Ãä3Ãä4Ãä5Ãä6Ãä7Ãä8Ãä9Ãä",
        'hook_above': "aÃâbÃâcÃâdÃâeÃâfÃâgÃâhÃâiÃâjÃâkÃâlÃâmÃânÃâoÃâpÃâqÃârÃâsÃâtÃâuÃâvÃâwÃâxÃâyÃâzÃâAÃâBÃâCÃâDÃâEÃâFÃâGÃâHÃâIÃâJÃâKÃâLÃâMÃâNÃâOÃâPÃâQÃâRÃâSÃâTÃâUÃâVÃâWÃâXÃâYÃâZÃâ0Ãâ1Ãâ2Ãâ3Ãâ4Ãâ5Ãâ6Ãâ7Ãâ8Ãâ9Ãâ",
        'horn': "aÃõbÃõcÃõdÃõeÃõfÃõgÃõhÃõiÃõjÃõkÃõlÃõmÃõnÃõoÃõpÃõqÃõrÃõsÃõtÃõuÃõvÃõwÃõxÃõyÃõzÃõAÃõBÃõCÃõDÃõEÃõFÃõGÃõHÃõIÃõJÃõKÃõLÃõMÃõNÃõOÃõPÃõQÃõRÃõSÃõTÃõUÃõVÃõWÃõXÃõYÃõZÃõ0Ãõ1Ãõ2Ãõ3Ãõ4Ãõ5Ãõ6Ãõ7Ãõ8Ãõ9Ãõ",
        'cedilla': "aÃßbÃßcÃßdÃßeÃßfÃßgÃßhÃßiÃßjÃßkÃßlÃßmÃßnÃßoÃßpÃßqÃßrÃßsÃßtÃßuÃßvÃßwÃßxÃßyÃßzÃßAÃßBÃßCÃßDÃßEÃßFÃßGÃßHÃßIÃßJÃßKÃßLÃßMÃßNÃßOÃßPÃßQÃßRÃßSÃßTÃßUÃßVÃßWÃßXÃßYÃßZÃß0Ãß1Ãß2Ãß3Ãß4Ãß5Ãß6Ãß7Ãß8Ãß9Ãß",
        'ogonek': "aÃ®bÃ®cÃ®dÃ®eÃ®fÃ®gÃ®hÃ®iÃ®jÃ®kÃ®lÃ®mÃ®nÃ®oÃ®pÃ®qÃ®rÃ®sÃ®tÃ®uÃ®vÃ®wÃ®xÃ®yÃ®zÃ®AÃ®BÃ®CÃ®DÃ®EÃ®FÃ®GÃ®HÃ®IÃ®JÃ®KÃ®LÃ®MÃ®NÃ®OÃ®PÃ®QÃ®RÃ®SÃ®TÃ®UÃ®VÃ®WÃ®XÃ®YÃ®ZÃ®0Ã®1Ã®2Ã®3Ã®4Ã®5Ã®6Ã®7Ã®8Ã®9Ã®",
        'caron': "aÃåbÃåcÃådÃåeÃåfÃågÃåhÃåiÃåjÃåkÃålÃåmÃånÃåoÃåpÃåqÃårÃåsÃåtÃåuÃåvÃåwÃåxÃåyÃåzÃåAÃåBÃåCÃåDÃåEÃåFÃåGÃåHÃåIÃåJÃåKÃåLÃåMÃåNÃåOÃåPÃåQÃåRÃåSÃåTÃåUÃåVÃåWÃåXÃåYÃåZÃå0Ãå1Ãå2Ãå3Ãå4Ãå5Ãå6Ãå7Ãå8Ãå9Ãå",
        'breve': "aÃÜbÃÜcÃÜdÃÜeÃÜfÃÜgÃÜhÃÜiÃÜjÃÜkÃÜlÃÜmÃÜnÃÜoÃÜpÃÜqÃÜrÃÜsÃÜtÃÜuÃÜvÃÜwÃÜxÃÜyÃÜzÃÜAÃÜBÃÜCÃÜDÃÜEÃÜFÃÜGÃÜHÃÜIÃÜJÃÜKÃÜLÃÜMÃÜNÃÜOÃÜPÃÜQÃÜRÃÜSÃÜTÃÜUÃÜVÃÜWÃÜXÃÜYÃÜZÃÜ0ÃÜ1ÃÜ2ÃÜ3ÃÜ4ÃÜ5ÃÜ6ÃÜ7ÃÜ8ÃÜ9ÃÜ",
        'macron': "aÃÑbÃÑcÃÑdÃÑeÃÑfÃÑgÃÑhÃÑiÃÑjÃÑkÃÑlÃÑmÃÑnÃÑoÃÑpÃÑqÃÑrÃÑsÃÑtÃÑuÃÑvÃÑwÃÑxÃÑyÃÑzÃÑAÃÑBÃÑCÃÑDÃÑEÃÑFÃÑGÃÑHÃÑIÃÑJÃÑKÃÑLÃÑMÃÑNÃÑOÃÑPÃÑQÃÑRÃÑSÃÑTÃÑUÃÑVÃÑWÃÑXÃÑYÃÑZÃÑ0ÃÑ1ÃÑ2ÃÑ3ÃÑ4ÃÑ5ÃÑ6ÃÑ7ÃÑ8ÃÑ9ÃÑ",
        'tilde': "aÃÉbÃÉcÃÉdÃÉeÃÉfÃÉgÃÉhÃÉiÃÉjÃÉkÃÉlÃÉmÃÉnÃÉoÃÉpÃÉqÃÉrÃÉsÃÉtÃÉuÃÉvÃÉwÃÉxÃÉyÃÉzÃÉAÃÉBÃÉCÃÉDÃÉEÃÉFÃÉGÃÉHÃÉIÃÉJÃÉKÃÉLÃÉMÃÉNÃÉOÃÉPÃÉQÃÉRÃÉSÃÉTÃÉUÃÉVÃÉWÃÉXÃÉYÃÉZÃÉ0ÃÉ1ÃÉ2ÃÉ3ÃÉ4ÃÉ5ÃÉ6ÃÉ7ÃÉ8ÃÉ9ÃÉ",
        'diaeresis': "aÃàbÃàcÃàdÃàeÃàfÃàgÃàhÃàiÃàjÃàkÃàlÃàmÃànÃàoÃàpÃàqÃàrÃàsÃàtÃàuÃàvÃàwÃàxÃàyÃàzÃàAÃàBÃàCÃàDÃàEÃàFÃàGÃàHÃàIÃàJÃàKÃàLÃàMÃàNÃàOÃàPÃàQÃàRÃàSÃàTÃàUÃàVÃàWÃàXÃàYÃàZÃà0Ãà1Ãà2Ãà3Ãà4Ãà5Ãà6Ãà7Ãà8Ãà9Ãà",
        'acute': "aÃÅbÃÅcÃÅdÃÅeÃÅfÃÅgÃÅhÃÅiÃÅjÃÅkÃÅlÃÅmÃÅnÃÅoÃÅpÃÅqÃÅrÃÅsÃÅtÃÅuÃÅvÃÅwÃÅxÃÅyÃÅzÃÅAÃÅBÃÅCÃÅDÃÅEÃÅFÃÅGÃÅHÃÅIÃÅJÃÅKÃÅLÃÅMÃÅNÃÅOÃÅPÃÅQÃÅRÃÅSÃÅTÃÅUÃÅVÃÅWÃÅXÃÅYÃÅZÃÅ0ÃÅ1ÃÅ2ÃÅ3ÃÅ4ÃÅ5ÃÅ6ÃÅ7ÃÅ8ÃÅ9ÃÅ",
        'grave': "aÃÄbÃÄcÃÄdÃÄeÃÄfÃÄgÃÄhÃÄiÃÄjÃÄkÃÄlÃÄmÃÄnÃÄoÃÄpÃÄqÃÄrÃÄsÃÄtÃÄuÃÄvÃÄwÃÄxÃÄyÃÄzÃÄAÃÄBÃÄCÃÄDÃÄEÃÄFÃÄGÃÄHÃÄIÃÄJÃÄKÃÄLÃÄMÃÄNÃÄOÃÄPÃÄQÃÄRÃÄSÃÄTÃÄUÃÄVÃÄWÃÄXÃÄYÃÄZÃÄ0ÃÄ1ÃÄ2ÃÄ3ÃÄ4ÃÄ5ÃÄ6ÃÄ7ÃÄ8ÃÄ9ÃÄ",
        'circumflex': "aÃÇbÃÇcÃÇdÃÇeÃÇfÃÇgÃÇhÃÇiÃÇjÃÇkÃÇlÃÇmÃÇnÃÇoÃÇpÃÇqÃÇrÃÇsÃÇtÃÇuÃÇvÃÇwÃÇxÃÇyÃÇzÃÇAÃÇBÃÇCÃÇDÃÇEÃÇFÃÇGÃÇHÃÇIÃÇJÃÇKÃÇLÃÇMÃÇNÃÇOÃÇPÃÇQÃÇRÃÇSÃÇTÃÇUÃÇVÃÇWÃÇXÃÇYÃÇZÃÇ0ÃÇ1ÃÇ2ÃÇ3ÃÇ4ÃÇ5ÃÇ6ÃÇ7ÃÇ8ÃÇ9ÃÇ",
    }
    
    # Small Caps Font for bot messages
    SMALL_CAPS_FONT = str.maketrans(
        "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",
        "·¥Ä ô·¥Ñ·¥Ö·¥á“ì…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ Äs·¥õ·¥ú·¥†·¥°x è·¥¢·¥Ä ô·¥Ñ·¥Ö·¥á“ì…¢ ú…™·¥ä·¥ã ü·¥ç…¥·¥è·¥ò«´ Äs·¥õ·¥ú·¥†·¥°x è·¥¢0123456789"
    )
    
    # Translation tables cache
    TRANSLATION_TABLES = {}
    
    @classmethod
    def _init_translation_tables(cls):
        """Initialize translation tables"""
        if not cls.TRANSLATION_TABLES:
            for font_name, font_chars in cls.FONTS.items():
                if len(cls.NORMAL) == len(font_chars):
                    cls.TRANSLATION_TABLES[font_name] = str.maketrans(cls.NORMAL, font_chars)
    
    # 1000+ Decorative Styles
    DECORATIVE_STYLES = [
        # Basic Decorations
        "ÍßÅ{}ÍßÇ", "‚´∑{}‚´∏", "„Äé{}„Äè", "‡º∫{}‡ºª", "‚ôõ{}‚ôõ", "‚ö°{}‚ö°", "‚ó•{}‚ó§", "‚ú¶{}‚ú¶",
        "‚ùñ{}‚ùñ", "‚åñ{}‚åñ", "‰∫ó{}‰∫ó", "Âçç{}Âçç", "„Äê{}„Äë", "„Äñ{}„Äó", "„Äà{}„Äâ", "¬´{}¬ª",
        "‚Äπ{}‚Ä∫", "‚ÅÖ{}‚ÅÜ", "‚åà{}‚åâ", "‚åä{}‚åã", "‚é∞{}‚é±", "‚é°{}‚é§", "‚é£{}‚é¶", "‚é°{}‚é¶",
        "‚é£{}‚é§", "‚é°{}‚é•", "‚é¢{}‚é¶", "‚é£{}‚é•", "‚é¢{}‚é§", "„Äé‚òÜ{}‚òÜ„Äè", "„Äé‚òÖ{}‚òÖ„Äè",
        "„Äé‚òØ{}‚òØ„Äè", "„Äé‚ò¨{}‚ò¨„Äè", "„Äé‚ò†{}‚ò†„Äè", "„Äé‚ò£{}‚ò£„Äè", "„Äé‚öú{}‚öú„Äè", "„Äé‚ú†{}‚ú†„Äè",
        "„Äé‚úß{}‚úß„Äè", "„Äé‚ú¶{}‚ú¶„Äè", "„Äé‚ùñ{}‚ùñ„Äè", "„Äé‚ú™{}‚ú™„Äè", "„Äé‚ú∞{}‚ú∞„Äè", "„Äé‚ùÇ{}‚ùÇ„Äè",
        "„Äé‚úµ{}‚úµ„Äè", "„Äé‚úØ{}‚úØ„Äè", "‚ïî‚ïê‚ïê‚ïê‚ú¶{}‚ú¶‚ïê‚ïê‚ïê‚ïó", "‚îè‚îÅ‚îÅ‚îÅ‚ùñ{}‚ùñ‚îÅ‚îÅ‚îÅ‚îì", "„Äê‚Ä†{}‚Ä†„Äë",
        "„Äé„Äñ{}„Äó„Äè", "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà{}‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ", "‚ñë‚ñí‚ñì‚ñà{}‚ñà‚ñì‚ñí‚ñë", "‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ{}‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà",
        "‚ïî‚ïê‚ïó{}‚ïî‚ïê‚ïó", "‚ñà‚ñ∂{}‚óÄ‚ñà", "‚óÑ{}‚ñ∫", "¬´{}¬ª", "‚â™{}‚â´", "‚ãò{}‚ãô", "‚ù∞{}‚ù±",
        "„Äî{}„Äï", "„Äñ{}„Äó", "„Äà{}„Äâ", "¬´¬´{}¬ª¬ª", "‚â™‚â™{}‚â´‚â´", "‚ñÑÔ∏ª„Éá‚ïê‚ïê‚îÅ‰∏Ä{}‰∏Ä‚ïê‚ïê„ÉáÔ∏ª‚ñÑ",
        "‚ïæ‚îÅ‚ï§„Éá‚ï¶Ô∏ª{}Ô∏ª‚ï¶„Éá‚ï§‚îÅ‚ïº", "Ô∏ª‚ï¶ÃµÃµÕáÃøÃøÃøÃø‚ï§‚îÄ‚îÄ{}‚îÄ‚îÄ‚ï§ÃµÃµÕáÃøÃøÃøÃø‚ï¶Ô∏ª", "„ÄêÔªø{}„Äë", "„Äé‚áù{}‚áú„Äè",
        "|!¬§*'~``~'*¬§!|{}|!¬§*'~``~'*¬§!|", "‚ïî‚ïê‚ïê‚ïê‚îÅ‚îÅ‚îÅ‚îÄ‚îÄ‚Ä¢{}‚Ä¢‚îÄ‚îÄ‚îÅ‚îÅ‚îÅ‚ïê‚ïê‚ïê‚ïó",
        "‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚â™‚Ä¢{}‚Ä¢‚â´‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó", "‚ïî‚ïê‚ïó‚Ä¢{}‚Ä¢‚ïî‚ïê‚ïó", "‚ïî‚ïó‚Ä¢{}‚Ä¢‚ïî‚ïó", "‚ïî‚ïó{}‚ïî‚ïó",
        "‚ïö‚ïó{}‚ïî‚ïù", "‚ïö‚ïê‚ïù{}‚ïö‚ïê‚ïù", "‚ïö‚ïù{}‚ïö‚ïù", "‚ó¢{}‚ó£", "‚ó£{}‚ó¢", "‚ó§{}‚ó•",
        "‚ó•{}‚ó§", "‚óà{}‚óà", "‚óá{}‚óá", "‚óÜ{}‚óÜ", "‚óâ{}‚óâ", "‚óé{}‚óé", "‚äô{}‚äô",
        "‚¶ø{}‚¶ø", "‚¶æ{}‚¶æ", "‚¶ø{}‚¶ø", "‚ßà{}‚ßà", "‚ßâ{}‚ßâ", "‚ßä{}‚ßä", "‚ßã{}‚ßã",
        "‚ßå{}‚ßå", "‚ßç{}‚ßç", "‚ßé{}‚ßé", "‚ßè{}‚ßè", "‚ßê{}‚ßê", "‚ßë{}‚ßë", "‚ßí{}‚ßí",
        "‚ßì{}‚ßì", "‚ßî{}‚ßî", "‚ßï{}‚ßï", "‚ßñ{}‚ßñ", "‚ßó{}‚ßó", "‚ßò{}‚ßò", "‚ßô{}‚ßô",
        "‚ßö{}‚ßö", "‚ßõ{}‚ßõ", "‚ßú{}‚ßú", "‚ßù{}‚ßù", "‚ßû{}‚ßû", "‚ßü{}‚ßü", "‚ß†{}‚ß†",
        "‚ß°{}‚ß°", "‚ß¢{}‚ß¢", "‚ß£{}‚ß£", "‚ß§{}‚ß§", "‚ß•{}‚ß•", "‚ß¶{}‚ß¶", "‚ßß{}‚ßß",
        "‚ß®{}‚ß®", "‚ß©{}‚ß©", "‚ß™{}‚ß™", "‚ß´{}‚ß´", "‚ß¨{}‚ß¨", "‚ß≠{}‚ß≠", "‚ßÆ{}‚ßÆ",
        "‚ßØ{}‚ßØ", "‚ß∞{}‚ß∞", "‚ß±{}‚ß±", "‚ß≤{}‚ß≤", "‚ß≥{}‚ß≥", "‚ß¥{}‚ß¥", "‚ßµ{}‚ßµ",
        "‚ß∂{}‚ß∂", "‚ß∑{}‚ß∑", "‚ß∏{}‚ß∏", "‚ßπ{}‚ßπ", "‚ß∫{}‚ß∫", "‚ßª{}‚ßª", "‚ßº{}‚ßº",
        "‚ßΩ{}‚ßΩ", "‚ßæ{}‚ßæ", "‚ßø{}‚ßø", "‚®Ä{}‚®Ä", "‚®Å{}‚®Å", "‚®Ç{}‚®Ç", "‚®É{}‚®É",
        "‚®Ñ{}‚®Ñ", "‚®Ö{}‚®Ö", "‚®Ü{}‚®Ü", "‚®á{}‚®á", "‚®à{}‚®à", "‚®â{}‚®â", "‚®ä{}‚®ä",
        "‚®ã{}‚®ã", "‚®å{}‚®å", "‚®ç{}‚®ç", "‚®é{}‚®é", "‚®è{}‚®è", "‚®ê{}‚®ê", "‚®ë{}‚®ë",
        "‚®í{}‚®í", "‚®ì{}‚®ì", "‚®î{}‚®î", "‚®ï{}‚®ï", "‚®ñ{}‚®ñ", "‚®ó{}‚®ó", "‚®ò{}‚®ò",
        "‚®ô{}‚®ô", "‚®ö{}‚®ö", "‚®õ{}‚®õ", "‚®ú{}‚®ú", "‚®ù{}‚®ù", "‚®û{}‚®û", "‚®ü{}‚®ü",
        "‚®†{}‚®†", "‚®°{}‚®°", "‚®¢{}‚®¢", "‚®£{}‚®£", "‚®§{}‚®§", "‚®•{}‚®•", "‚®¶{}‚®¶",
        "‚®ß{}‚®ß", "‚®®{}‚®®", "‚®©{}‚®©", "‚®™{}‚®™", "‚®´{}‚®´", "‚®¨{}‚®¨", "‚®≠{}‚®≠",
        "‚®Æ{}‚®Æ", "‚®Ø{}‚®Ø", "‚®∞{}‚®∞", "‚®±{}‚®±", "‚®≤{}‚®≤", "‚®≥{}‚®≥", "‚®¥{}‚®¥",
        "‚®µ{}‚®µ", "‚®∂{}‚®∂", "‚®∑{}‚®∑", "‚®∏{}‚®∏", "‚®π{}‚®π", "‚®∫{}‚®∫", "‚®ª{}‚®ª",
        "‚®º{}‚®º", "‚®Ω{}‚®Ω", "‚®æ{}‚®æ", "‚®ø{}‚®ø", "‚©Ä{}‚©Ä", "‚©Å{}‚©Å", "‚©Ç{}‚©Ç",
        "‚©É{}‚©É", "‚©Ñ{}‚©Ñ", "‚©Ö{}‚©Ö", "‚©Ü{}‚©Ü", "‚©á{}‚©á", "‚©à{}‚©à", "‚©â{}‚©â",
        "‚©ä{}‚©ä", "‚©ã{}‚©ã", "‚©å{}‚©å", "‚©ç{}‚©ç", "‚©é{}‚©é", "‚©è{}‚©è", "‚©ê{}‚©ê",
        "‚©ë{}‚©ë", "‚©í{}‚©í", "‚©ì{}‚©ì", "‚©î{}‚©î", "‚©ï{}‚©ï", "‚©ñ{}‚©ñ", "‚©ó{}‚©ó",
        "‚©ò{}‚©ò", "‚©ô{}‚©ô", "‚©ö{}‚©ö", "‚©õ{}‚©õ", "‚©ú{}‚©ú", "‚©ù{}‚©ù", "‚©û{}‚©û",
        "‚©ü{}‚©ü", "‚©†{}‚©†", "‚©°{}‚©°", "‚©¢{}‚©¢", "‚©£{}‚©£", "‚©§{}‚©§", "‚©•{}‚©•",
        "‚©¶{}‚©¶", "‚©ß{}‚©ß", "‚©®{}‚©®", "‚©©{}‚©©", "‚©™{}‚©™", "‚©´{}‚©´", "‚©¨{}‚©¨",
        "‚©≠{}‚©≠", "‚©Æ{}‚©Æ", "‚©Ø{}‚©Ø", "‚©∞{}‚©∞", "‚©±{}‚©±", "‚©≤{}‚©≤", "‚©≥{}‚©≥",
        "‚©¥{}‚©¥", "‚©µ{}‚©µ", "‚©∂{}‚©∂", "‚©∑{}‚©∑", "‚©∏{}‚©∏", "‚©π{}‚©π", "‚©∫{}‚©∫",
        "‚©ª{}‚©ª", "‚©º{}‚©º", "‚©Ω{}‚©Ω", "‚©æ{}‚©æ", "‚©ø{}‚©ø", "‚™Ä{}‚™Ä", "‚™Å{}‚™Å",
        "‚™Ç{}‚™Ç", "‚™É{}‚™É", "‚™Ñ{}‚™Ñ", "‚™Ö{}‚™Ö", "‚™Ü{}‚™Ü", "‚™á{}‚™á", "‚™à{}‚™à",
        "‚™â{}‚™â", "‚™ä{}‚™ä", "‚™ã{}‚™ã", "‚™å{}‚™å", "‚™ç{}‚™ç", "‚™é{}‚™é", "‚™è{}‚™è",
        "‚™ê{}‚™ê", "‚™ë{}‚™ë", "‚™í{}‚™í", "‚™ì{}‚™ì", "‚™î{}‚™î", "‚™ï{}‚™ï", "‚™ñ{}‚™ñ",
        "‚™ó{}‚™ó", "‚™ò{}‚™ò", "‚™ô{}‚™ô", "‚™ö{}‚™ö", "‚™õ{}‚™õ", "‚™ú{}‚™ú", "‚™ù{}‚™ù",
        "‚™û{}‚™û", "‚™ü{}‚™ü", "‚™†{}‚™†", "‚™°{}‚™°", "‚™¢{}‚™¢", "‚™£{}‚™£", "‚™§{}‚™§",
        "‚™•{}‚™•", "‚™¶{}‚™¶", "‚™ß{}‚™ß", "‚™®{}‚™®", "‚™©{}‚™©", "‚™™{}‚™™", "‚™´{}‚™´",
        "‚™¨{}‚™¨", "‚™≠{}‚™≠", "‚™Æ{}‚™Æ", "‚™Ø{}‚™Ø", "‚™∞{}‚™∞", "‚™±{}‚™±", "‚™≤{}‚™≤",
        "‚™≥{}‚™≥", "‚™¥{}‚™¥", "‚™µ{}‚™µ", "‚™∂{}‚™∂", "‚™∑{}‚™∑", "‚™∏{}‚™∏", "‚™π{}‚™π",
        "‚™∫{}‚™∫", "‚™ª{}‚™ª", "‚™º{}‚™º", "‚™Ω{}‚™Ω", "‚™æ{}‚™æ", "‚™ø{}‚™ø", "‚´Ä{}‚´Ä",
        "‚´Å{}‚´Å", "‚´Ç{}‚´Ç", "‚´É{}‚´É", "‚´Ñ{}‚´Ñ", "‚´Ö{}‚´Ö", "‚´Ü{}‚´Ü", "‚´á{}‚´á",
        "‚´à{}‚´à", "‚´â{}‚´â", "‚´ä{}‚´ä", "‚´ã{}‚´ã", "‚´å{}‚´å", "‚´ç{}‚´ç", "‚´é{}‚´é",
        "‚´è{}‚´è", "‚´ê{}‚´ê", "‚´ë{}‚´ë", "‚´í{}‚´í", "‚´ì{}‚´ì", "‚´î{}‚´î", "‚´ï{}‚´ï",
        "‚´ñ{}‚´ñ", "‚´ó{}‚´ó", "‚´ò{}‚´ò", "‚´ô{}‚´ô", "‚´ö{}‚´ö", "‚´õ{}‚´õ", "‚´ú{}‚´ú",
        "‚´ù{}‚´ù", "‚´û{}‚´û", "‚´ü{}‚´ü", "‚´†{}‚´†", "‚´°{}‚´°", "‚´¢{}‚´¢", "‚´£{}‚´£",
        "‚´§{}‚´§", "‚´•{}‚´•", "‚´¶{}‚´¶", "‚´ß{}‚´ß", "‚´®{}‚´®", "‚´©{}‚´©", "‚´™{}‚´™",
        "‚´´{}‚´´", "‚´¨{}‚´¨", "‚´≠{}‚´≠", "‚´Æ{}‚´Æ", "‚´Ø{}‚´Ø", "‚´∞{}‚´∞", "‚´±{}‚´±",
        "‚´≤{}‚´≤", "‚´≥{}‚´≥", "‚´¥{}‚´¥", "‚´µ{}‚´µ", "‚´∂{}‚´∂", "‚´∑{}‚´∑", "‚´∏{}‚´∏",
        "‚´π{}‚´π", "‚´∫{}‚´∫", "‚´ª{}‚´ª", "‚´º{}‚´º", "‚´Ω{}‚´Ω", "‚´æ{}‚´æ", "‚´ø{}‚´ø",
        
        # Emoji Styles (200+)
        "üòà{}üòà", "üëë{}üëë", "üî•{}üî•", "‚ö°{}‚ö°", "‚ú®{}‚ú®", "üéØ{}üéØ", "üé≠{}üé≠",
        "üéÆ{}üéÆ", "üíÄ{}üíÄ", "ü§ñ{}ü§ñ", "üëª{}üëª", "üëΩ{}üëΩ", "ü§¥{}ü§¥", "üë∏{}üë∏",
        "ü¶∏{}ü¶∏", "ü¶π{}ü¶π", "üßô{}üßô", "üßõ{}üßõ", "üßü{}üßü", "üßû{}üßû", "üßö{}üßö",
        "ü¶Ñ{}ü¶Ñ", "üêâ{}üêâ", "üê≤{}üê≤", "ü¶Å{}ü¶Å", "üêØ{}üêØ", "üê∫{}üê∫", "ü¶ä{}ü¶ä",
        "üêç{}üêç", "ü¶Ö{}ü¶Ö", "ü¶á{}ü¶á", "üï∑Ô∏è{}üï∑Ô∏è", "üï∏Ô∏è{}üï∏Ô∏è", "üíé{}üíé", "‚öîÔ∏è{}‚öîÔ∏è",
        "üõ°Ô∏è{}üõ°Ô∏è", "üèπ{}üèπ", "üî´{}üî´", "üó°Ô∏è{}üó°Ô∏è", "üî±{}üî±", "‚öúÔ∏è{}‚öúÔ∏è", "ü¶†{}ü¶†",
        "‚ô°{}‚ô°", "‚ô•{}‚ô•", "‚ù•{}‚ù•", "·É¶{}·É¶", "‚ù¶{}‚ù¶", "‚ùß{}‚ùß", "‚òØ{}‚òØ", "‚òÆ{}‚òÆ",
        "‚ò™{}‚ò™", "‚ú°{}‚ú°", "‚öõ{}‚öõ", "üïâ{}üïâ", "‚úù{}‚úù", "‚úû{}‚úû", "‚úü{}‚úü", "‚ò¶{}‚ò¶",
        "üïé{}üïé", "üîØ{}üîØ", "üîº{}üîº", "üîΩ{}üîΩ", "‚è´{}‚è´", "‚è¨{}‚è¨", "‚è≠Ô∏è{}‚è≠Ô∏è",
        "‚èÆÔ∏è{}‚èÆÔ∏è", "‚è∏Ô∏è{}‚è∏Ô∏è", "‚èπÔ∏è{}‚èπÔ∏è", "‚è∫Ô∏è{}‚è∫Ô∏è", "‚èèÔ∏è{}‚èèÔ∏è", "üé¶{}üé¶", "üîÖ{}üîÖ",
        "üîÜ{}üîÜ", "üìõ{}üìõ", "üìú{}üìú", "üì∞{}üì∞", "üè¥{}üè¥", "üè≥Ô∏è{}üè≥Ô∏è", "üè¥‚Äç‚ò†Ô∏è{}üè¥‚Äç‚ò†Ô∏è",
        "üè≥Ô∏è‚Äçüåà{}üè≥Ô∏è‚Äçüåà", "üá∫üá≥{}üá∫üá≥", "üá∫üá∏{}üá∫üá∏", "üá¨üáß{}üá¨üáß", "üá©üá™{}üá©üá™", "üá´üá∑{}üá´üá∑",
        "üáÆüáπ{}üáÆüáπ", "üá™üá∏{}üá™üá∏", "üá∑üá∫{}üá∑üá∫", "üá®üá≥{}üá®üá≥", "üáØüáµ{}üáØüáµ", "üá∞üá∑{}üá∞üá∑",
        "üáÆüá≥{}üáÆüá≥", "üáßüá©{}üáßüá©", "üáµüá∞{}üáµüá∞", "üá∏üá¶{}üá∏üá¶", "üá¶üá™{}üá¶üá™", "üá∂üá¶{}üá∂üá¶",
        "üéÆ{}üéÆ", "üïπÔ∏è{}üïπÔ∏è", "üëæ{}üëæ", "üñ•Ô∏è{}üñ•Ô∏è", "üíª{}üíª", "üì±{}üì±", "üé≤{}üé≤",
        "üé∞{}üé∞", "üéØ{}üéØ", "üé≥{}üé≥", "üèì{}üèì", "üè∏{}üè∏", "ü•ä{}ü•ä", "ü•ã{}ü•ã",
        "‚õ∏Ô∏è{}‚õ∏Ô∏è", "üéø{}üéø", "‚õ∑Ô∏è{}‚õ∑Ô∏è", "üèÇ{}üèÇ", "üèÑ{}üèÑ", "üèä{}üèä", "ü§Ω{}ü§Ω",
        "üèãÔ∏è{}üèãÔ∏è", "ü§∏{}ü§∏", "ü§æ{}ü§æ", "ü§∫{}ü§∫", "ü•å{}ü•å", "üéñÔ∏è{}üéñÔ∏è", "üèÜ{}üèÜ",
        "üèÖ{}üèÖ", "ü•á{}ü•á", "ü•à{}ü•à", "ü•â{}ü•â", "‚öΩ{}‚öΩ", "üèÄ{}üèÄ", "üèà{}üèà",
        "‚öæ{}‚öæ", "üéæ{}üéæ", "üèê{}üèê", "üèâ{}üèâ", "üé±{}üé±", "üèè{}üèè", "üèë{}üèë",
        "üèí{}üèí", "üèì{}üèì", "üè∏{}üè∏", "ü•Ö{}ü•Ö", "ü•ä{}ü•ä", "ü•ã{}ü•ã", "ü•è{}ü•è",
        "ü•ç{}ü•ç", "ü™É{}ü™É", "ü™Å{}ü™Å", "ü™Ç{}ü™Ç", "ü§ø{}ü§ø", "ü•Ω{}ü•Ω", "ü•º{}ü•º",
        "ü¶∫{}ü¶∫", "üëë{}üëë", "üëí{}üëí", "üé©{}üé©", "üéì{}üéì", "üß¢{}üß¢", "‚õëÔ∏è{}‚õëÔ∏è",
        "üìø{}üìø", "üíÑ{}üíÑ", "üíç{}üíç", "üíé{}üíé", "üî™{}üî™", "üí£{}üí£", "üß®{}üß®",
        "üìØ{}üìØ", "üóúÔ∏è{}üóúÔ∏è", "‚öôÔ∏è{}‚öôÔ∏è", "üî©{}üî©", "‚öóÔ∏è{}‚öóÔ∏è", "üî¨{}üî¨", "üî≠{}üî≠",
        "üì°{}üì°", "üíâ{}üíâ", "üíä{}üíä", "üß™{}üß™", "üß´{}üß´", "üß¨{}üß¨", "üîã{}üîã",
        "üîå{}üîå", "üí°{}üí°", "üî¶{}üî¶", "üïØÔ∏è{}üïØÔ∏è", "üßØ{}üßØ", "üõ¢Ô∏è{}üõ¢Ô∏è", "‚ö±Ô∏è{}‚ö±Ô∏è",
        "üóø{}üóø", "ü™®{}ü™®", "ü™µ{}ü™µ", "üå±{}üå±", "üå≤{}üå≤", "üå≥{}üå≥", "üå¥{}üå¥",
        "üåµ{}üåµ", "üåæ{}üåæ", "üåø{}üåø", "üçÄ{}üçÄ", "üçÅ{}üçÅ", "üçÇ{}üçÇ", "üçÉ{}üçÉ",
        "üçÑ{}üçÑ", "üå∞{}üå∞", "ü¶¥{}ü¶¥", "ü¶∑{}ü¶∑", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥",
        "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥",
        "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥",
        "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥", "ü¶¥{}ü¶¥",
    ]
    
    # 500+ Art Styles
    ART_STYLES = [
        "‚ñë‚ñí‚ñì‚ñà{}‚ñà‚ñì‚ñí‚ñë", "‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ{}‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà", "‚ïî‚ïê‚ïó{}‚ïî‚ïê‚ïó", "‚ñà‚ñ∂{}‚óÄ‚ñà",
        "‚óÑ{}‚ñ∫", "¬´{}¬ª", "‚â™{}‚â´", "‚ãò{}‚ãô", "‚ù∞{}‚ù±", "„Äî{}„Äï", "„Äê{}„Äë",
        "„Äñ{}„Äó", "„Äà{}„Äâ", "¬´¬´{}¬ª¬ª", "‚â™‚â™{}‚â´‚â´", "‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà{}‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ",
        "‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë{}‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë", "‚ñí‚ñì‚ñà‚ñì‚ñí‚ñë{}‚ñë‚ñí‚ñì‚ñà‚ñì‚ñí", "‚ñì‚ñà‚ñì‚ñí‚ñë{}‚ñë‚ñí‚ñì‚ñà‚ñì", "‚ñà‚ñì‚ñí‚ñë{}‚ñë‚ñí‚ñì‚ñà",
        "‚ñì‚ñí‚ñë{}‚ñë‚ñí‚ñì", "‚ñí‚ñë{}‚ñë‚ñí", "‚ñë{}‚ñë", "‚ñí{}‚ñí", "‚ñì{}‚ñì", "‚ñà{}‚ñà",
        "‚ñÄ‚ñÑ‚ñÄ‚ñÑ‚ñÄ‚ñÑ{}‚ñÑ‚ñÄ‚ñÑ‚ñÄ‚ñÑ‚ñÄ", "‚ñÑ‚ñÄ‚ñÑ‚ñÄ‚ñÑ‚ñÄ{}‚ñÄ‚ñÄ‚ñÄ‚ñÑ‚ñÄ‚ñÑ", "‚ñÄ‚ñà‚ñÄ‚ñà‚ñÄ‚ñà{}‚ñà‚ñÄ‚ñà‚ñÄ‚ñà‚ñÄ",
        "‚ñà‚ñÄ‚ñà‚ñÄ‚ñà‚ñÄ{}‚ñÄ‚ñà‚ñÄ‚ñà‚ñÄ‚ñà", "‚ñì‚ñí‚ñì‚ñí‚ñì‚ñí{}‚ñí‚ñì‚ñí‚ñì‚ñí‚ñì", "‚ñí‚ñì‚ñí‚ñì‚ñí‚ñì{}‚ñì‚ñí‚ñì‚ñí‚ñì‚ñí",
        "‚ñë‚ñì‚ñë‚ñì‚ñë‚ñì{}‚ñì‚ñë‚ñì‚ñë‚ñì‚ñë", "‚ñì‚ñë‚ñì‚ñë‚ñì‚ñë{}‚ñë‚ñì‚ñë‚ñì‚ñë‚ñì", "‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë{}‚ñë‚ñí‚ñë‚ñí‚ñë‚ñí",
        "‚ñë‚ñí‚ñë‚ñí‚ñë‚ñí{}‚ñí‚ñë‚ñí‚ñë‚ñí‚ñë", "‚ñà‚ñë‚ñà‚ñë‚ñà‚ñë{}‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà", "‚ñë‚ñà‚ñë‚ñà‚ñë‚ñà{}‚ñà‚ñë‚ñà‚ñë‚ñà‚ñë",
        "‚ñÄ‚ñë‚ñÄ‚ñë‚ñÄ‚ñë{}‚ñë‚ñÄ‚ñë‚ñÄ‚ñë‚ñÄ", "‚ñë‚ñÄ‚ñë‚ñÄ‚ñë‚ñÄ{}‚ñÄ‚ñë‚ñÄ‚ñë‚ñÄ‚ñë", "‚ñ†‚ñ°‚ñ†‚ñ°‚ñ†{}‚ñ°‚ñ†‚ñ°‚ñ†‚ñ°",
        "‚ñ°‚ñ†‚ñ°‚ñ†‚ñ°{}‚ñ†‚ñ°‚ñ†‚ñ°‚ñ†", "‚óè‚óã‚óè‚óã‚óè{}‚óã‚óè‚óã‚óè‚óã", "‚óã‚óè‚óã‚óè‚óã{}‚óè‚óã‚óè‚óã‚óè",
        "‚ñ≤‚ñ≥‚ñ≤‚ñ≥‚ñ≤{}‚ñ≥‚ñ≤‚ñ≥‚ñ≤‚ñ≥", "‚ñ≥‚ñ≤‚ñ≥‚ñ≤‚ñ≥{}‚ñ≤‚ñ≥‚ñ≤‚ñ≥‚ñ≤", "‚ñº‚ñΩ‚ñº‚ñΩ‚ñº{}‚ñΩ‚ñº‚ñΩ‚ñº‚ñΩ",
        "‚ñΩ‚ñº‚ñΩ‚ñº‚ñΩ{}‚ñº‚ñΩ‚ñº‚ñΩ‚ñº", "‚óÜ‚óá‚óÜ‚óá‚óÜ{}‚óá‚óÜ‚óá‚óÜ‚óá", "‚óá‚óÜ‚óá‚óÜ‚óá{}‚óÜ‚óá‚óÜ‚óá‚óÜ",
        "‚òÖ‚òÜ‚òÖ‚òÜ‚òÖ{}‚òÜ‚òÖ‚òÜ‚òÖ‚òÜ", "‚òÜ‚òÖ‚òÜ‚òÖ‚òÜ{}‚òÖ‚òÜ‚òÖ‚òÜ‚òÖ", "‚ô†‚ô°‚ô†‚ô°‚ô†{}‚ô°‚ô†‚ô°‚ô†‚ô°",
        "‚ô°‚ô†‚ô°‚ô†‚ô°{}‚ô†‚ô°‚ô°‚ô†‚ô°", "‚ô£‚ô¶‚ô£‚ô¶‚ô£{}‚ô¶‚ô£‚ô¶‚ô£‚ô¶", "‚ô¶‚ô£‚ô¶‚ô£‚ô¶{}‚ô£‚ô¶‚ô£‚ô¶‚ô£",
        "‚ö´‚ö™‚ö´‚ö™‚ö´{}‚ö™‚ö´‚ö™‚ö´‚ö™", "‚ö™‚ö´‚ö™‚ö´‚ö™{}‚ö´‚ö™‚ö´‚ö™‚ö´",
        "‚¨õ‚¨ú‚¨õ‚¨ú‚¨õ{}‚¨ú‚¨õ‚¨ú‚¨õ‚¨ú", "‚¨ú‚¨õ‚¨ú‚¨õ‚¨ú{}‚¨õ‚¨ú‚¨õ‚¨ú‚¨õ",
        "‚ñ™Ô∏è‚ñ´Ô∏è‚ñ™Ô∏è‚ñ´Ô∏è‚ñ™Ô∏è{}‚ñ´Ô∏è‚ñ™Ô∏è‚ñ´Ô∏è‚ñ™Ô∏è‚ñ´Ô∏è", "‚ñ´Ô∏è‚ñ™Ô∏è‚ñ´Ô∏è‚ñ™Ô∏è‚ñ´Ô∏è{}‚ñ™Ô∏è‚ñ´Ô∏è‚ñ™Ô∏è‚ñ´Ô∏è‚ñ™Ô∏è",
        "‚óºÔ∏è‚óªÔ∏è‚óºÔ∏è‚óªÔ∏è‚óºÔ∏è{}‚óªÔ∏è‚óºÔ∏è‚óªÔ∏è‚óºÔ∏è‚óªÔ∏è", "‚óªÔ∏è‚óºÔ∏è‚óªÔ∏è‚óºÔ∏è‚óªÔ∏è{}‚óºÔ∏è‚óªÔ∏è‚óºÔ∏è‚óªÔ∏è‚óºÔ∏è",
        "‚óæ‚óΩ‚óæ‚óΩ‚óæ{}‚óΩ‚óæ‚óΩ‚óæ‚óΩ", "‚óΩ‚óæ‚óΩ‚óæ‚óΩ{}‚óæ‚óΩ‚óæ‚óΩ‚óæ",
        "üî≥üî≤üî≥üî≤üî≥{}üî≤üî≥üî≤üî≥üî≤", "üî≤üî≥üî≤üî≥üî≤{}üî≥üî≤üî≥üî≤üî≥",
        "üü•üüßüü®üü©üü¶{}üü™üü´‚¨õ‚¨ú", "üüßüü®üü©üü¶üü™{}üü´‚¨õ‚¨úüü•",
        "üü®üü©üü¶üü™üü´{}‚¨õ‚¨úüü•üüß", "üü©üü¶üü™üü´‚¨õ{}‚¨úüü•üüßüü®",
        "üü¶üü™üü´‚¨õ‚¨ú{}üü•üüßüü®üü©", "üü™üü´‚¨õ‚¨úüü•{}üüßüü®üü©üü¶",
        "üü´‚¨õ‚¨úüü•üüß{}üü®üü©üü¶üü™", "‚¨õ‚¨úüü•üüßüü®{}üü©üü¶üü™üü´",
        "‚¨úüü•üüßüü®üü©{}üü¶üü™üü´‚¨õ", "üü•üüßüü®üü©üü¶{}üü™üü´‚¨õ‚¨ú",
        "üî¥üü†üü°üü¢üîµ{}üü£üü§‚ö´‚ö™", "üü†üü°üü¢üîµüü£{}üü§‚ö´‚ö™üî¥",
        "üü°üü¢üîµüü£üü§{}‚ö´‚ö™üî¥üü†", "üü¢üîµüü£üü§‚ö´{}‚ö™üî¥üü†üü°",
        "üîµüü£üü§‚ö´‚ö™{}üî¥üü†üü°üü¢", "üü£üü§‚ö´‚ö™üî¥{}üü†üü°üü¢üîµ",
        "üü§‚ö´‚ö™üî¥üü†{}üü°üü¢üîµüü£", "‚ö´‚ö™üî¥üü†üü°{}üü¢üîµüü£üü§",
        "‚ö™üî¥üü†üü°üü¢{}üîµüü£üü§‚ö´", "üî¥üü†üü°üü¢üîµ{}üü£üü§‚ö´‚ö™",
        "‚≠ï‚ùå‚≠ï‚ùå‚≠ï{}‚ùå‚≠ï‚ùå‚≠ï‚ùå", "‚ùå‚≠ï‚ùå‚≠ï‚ùå{}‚≠ï‚ùå‚≠ï‚ùå‚≠ï",
        "‚úÖ‚ùé‚úÖ‚ùé‚úÖ{}‚ùé‚úÖ‚ùé‚úÖ‚ùé", "‚ùé‚úÖ‚ùé‚úÖ‚ùé{}‚úÖ‚ùé‚úÖ‚ùé‚úÖ",
        "‚òëÔ∏èüîò‚òëÔ∏èüîò‚òëÔ∏è{}üîò‚òëÔ∏èüîò‚òëÔ∏èüîò", "üîò‚òëÔ∏èüîò‚òëÔ∏èüîò{}‚òëÔ∏èüîò‚òëÔ∏èüîò‚òëÔ∏è",
        "‚ö™üî¥‚ö™üî¥‚ö™{}üî¥‚ö™üî¥‚ö™üî¥", "üî¥‚ö™üî¥‚ö™üî¥{}‚ö™üî¥‚ö™üî¥‚ö™",
        "üîµüü¢üîµüü¢üîµ{}üü¢üîµüü¢üîµüü¢", "üü¢üîµüü¢üîµüü¢{}üîµüü¢üîµüü¢üîµ",
        "üü°üü†üü°üü†üü°{}üü†üü°üü†üü°üü†", "üü†üü°üü†üü°üü†{}üü°üü†üü°üü†üü°",
        "üü£üü§üü£üü§üü£{}üü§üü£üü§üü£üü§", "üü§üü£üü§üü£üü§{}üü£üü§üü£üü§üü£",
        "‚ö´‚ö™‚ö´‚ö™‚ö´{}‚ö™‚ö´‚ö™‚ö´‚ö™", "‚ö™‚ö´‚ö™‚ö´‚ö™{}‚ö´‚ö™‚ö´‚ö™‚ö´",
        "‚¨õ‚¨ú‚¨õ‚¨ú‚¨õ{}‚¨ú‚¨õ‚¨ú‚¨õ‚¨ú", "‚¨ú‚¨õ‚¨ú‚¨õ‚¨ú{}‚¨õ‚¨ú‚¨õ‚¨ú‚¨õ",
    ]
    
    # Mixed Styles (Font + Decoration)
    MIXED_STYLES = []
    
    @classmethod
    def generate_mixed_styles(cls):
        """Generate mixed styles"""
        if not cls.MIXED_STYLES:
            mixed = []
            fonts = list(cls.FONTS.keys())
            decorations = cls.DECORATIVE_STYLES[:50]  # Use first 50 decorations
            
            for font in fonts[:20]:  # Use first 20 fonts
                for decor in decorations[:20]:  # Use first 20 decorations
                    mixed.append((font, decor))
            
            # Special combinations
            special_combos = [
                ('bold', 'ÍßÅ{}ÍßÇ'), ('italic', '„Äé{}„Äè'), ('monospace', '‚ôõ{}‚ôõ'),
                ('bubble', '‚ö°{}‚ö°'), ('gothic', '„Äê{}„Äë'), ('double_struck', '„Äñ{}„Äó'),
                ('script', '‚ùñ{}‚ùñ'), ('fraktur', '‚ñÑÔ∏ª„Éá‚ïê‚ïê‚îÅ‰∏Ä{}‰∏Ä‚ïê‚ïê„ÉáÔ∏ª‚ñÑ'),
                ('blackboard', '‚ïî‚ïê‚ïê‚ïê‚ú¶{}‚ú¶‚ïê‚ïê‚ïê‚ïó'), ('small_caps', '‚îè‚îÅ‚îÅ‚îÅ‚ùñ{}‚ùñ‚îÅ‚îÅ‚îÅ‚îì'),
                ('superscript', 'üòà{}üòà'), ('subscript', 'üëë{}üëë'), ('outline', 'üî•{}üî•'),
                ('heavy', '‚ö°{}‚ö°'), ('cursive', '‚ú®{}‚ú®'), ('upside_down', 'üéØ{}üéØ'),
                ('wide', '„Äé‚òÜ{}‚òÜ„Äè'), ('narrow', '„Äé‚òÖ{}‚òÖ„Äè'), ('strikethrough', '„Äé‚òØ{}‚òØ„Äè'),
                ('underline', '„Äé‚ò¨{}‚ò¨„Äè'), ('overline', '„Äé‚ò†{}‚ò†„Äè'), ('double_underline', '„Äé‚ò£{}‚ò£„Äè'),
                ('squiggle', '„Äé‚öú{}‚öú„Äè'), ('wave', '„Äé‚ú†{}‚ú†„Äè'), ('slash', '„Äé‚úß{}‚úß„Äè'),
                ('x_through', '„Äé‚ú¶{}‚ú¶„Äè'), ('asterisk', '„Äé‚ùñ{}‚ùñ„Äè'), ('dot_above', '„Äé‚ú™{}‚ú™„Äè'),
                ('dot_below', '„Äé‚ú∞{}‚ú∞„Äè'), ('ring_above', '„Äé‚ùÇ{}‚ùÇ„Äè'), ('hook_above', '„Äé‚úµ{}‚úµ„Äè'),
                ('horn', '„Äé‚úØ{}‚úØ„Äè'), ('cedilla', '‚ïî‚ïê‚ïê‚ïê‚ú¶{}‚ú¶‚ïê‚ïê‚ïê‚ïó'), ('ogonek', '‚îè‚îÅ‚îÅ‚îÅ‚ùñ{}‚ùñ‚îÅ‚îÅ‚îÅ‚îì'),
                ('caron', '„Äê‚Ä†{}‚Ä†„Äë'), ('breve', '„Äé„Äñ{}„Äó„Äè'), ('macron', '‚ñÅ‚ñÇ‚ñÉ‚ñÑ‚ñÖ‚ñÜ‚ñá‚ñà{}‚ñà‚ñá‚ñÜ‚ñÖ‚ñÑ‚ñÉ‚ñÇ‚ñÅ'),
                ('tilde', '‚ñë‚ñí‚ñì‚ñà{}‚ñà‚ñì‚ñí‚ñë'), ('diaeresis', '‚ñà‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ{}‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñÄ‚ñà'),
                ('acute', '‚ïî‚ïê‚ïó{}‚ïî‚ïê‚ïó'), ('grave', '‚ñà‚ñ∂{}‚óÄ‚ñà'), ('circumflex', '‚óÑ{}‚ñ∫'),
            ]
            
            cls.MIXED_STYLES = mixed + special_combos
    
    @classmethod
    def apply_font(cls, text: str, font_name: str) -> str:
        """Apply font to text"""
        if not cls.TRANSLATION_TABLES:
            cls._init_translation_tables()
        
        if font_name == 'small_caps':
            return text.translate(cls.SMALL_CAPS_FONT)
        
        table = cls.TRANSLATION_TABLES.get(font_name)
        if table:
            return text.translate(table)
        return text
    
    @classmethod
    def apply_style(cls, text: str, style_type: str, style_template: str = None) -> str:
        """Apply style to text"""
        if style_type == "font" and style_template:
            return cls.apply_font(text, style_template)
        elif style_type == "decorative" and style_template:
            return style_template.format(text)
        elif style_type == "art" and style_template:
            return style_template.format(text)
        elif style_type == "mixed" and style_template:
            font_name, decor = style_template
            font_text = cls.apply_font(text, font_name)
            return decor.format(font_text)
        return text

# ==================== TEXT STORAGE ====================
class TextStorage:
    """Fast text storage with hash"""
    _storage = {}
    
    @classmethod
    def store_text(cls, text: str) -> str:
        """Store text and return hash"""
        text_hash = hashlib.md5(text.encode()).hexdigest()[:16]
        cls._storage[text_hash] = text
        return text_hash
    
    @classmethod
    def get_text(cls, text_hash: str) -> str:
        """Get text by hash"""
        return cls._storage.get(text_hash, "")

# ==================== BOT HANDLERS ====================
class BotHandlers:
    def __init__(self):
        self.font_styles = FontStyles()
        self.text_storage = TextStorage()
        self.font_styles.generate_mixed_styles()
        self.font_styles._init_translation_tables()
    
    def apply_small_caps(self, text: str) -> str:
        """Apply small caps font"""
        return text.translate(FontStyles.SMALL_CAPS_FONT)
    
    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /start command"""
        try:
            user = update.effective_user
            
            # Add user to database
            await asyncio.get_event_loop().run_in_executor(
                None, Database.add_user, user.id, user.first_name, user.username
            )
            
            welcome_msg = self.apply_small_caps(
                f"‚ú® ·¥°·¥á ü·¥Ñ·¥è·¥ç·¥á {user.first_name}! ‚ú®\n\n"
                "üé® s·¥õ è ü…™s ú …¥·¥Ä·¥ç·¥á  ô·¥è·¥õ\n"
                "‚Ä¢ 2000+ s·¥õ è ü·¥ás/“ì·¥è…¥·¥õs/·¥Ä Ä·¥õ\n"
                "‚Ä¢ …™…¥s·¥õ·¥Ä…¥·¥õ ·¥è…¥·¥á-·¥Ñ ü…™·¥Ñ·¥ã ·¥Ñ·¥è·¥ò è\n"
                "‚Ä¢ “ì·¥Äs·¥õ ·¥ò·¥Ä…¢…™…¥·¥Ä·¥õ…™·¥è…¥\n\n"
                "üëá ·¥Ñ ú·¥è·¥ès·¥á ·¥Ä…¥ ·¥è·¥ò·¥õ…™·¥è…¥:"
            )
            
            keyboard = [
                [InlineKeyboardButton("üé® ·¥Ñ Ä·¥á·¥Ä·¥õ·¥á s·¥õ è ü·¥á", callback_data='create_style')],
                [InlineKeyboardButton("üé≤  Ä·¥Ä…¥·¥Ö·¥è·¥ç …¥·¥Ä·¥ç·¥á", callback_data='random_name')],
                [InlineKeyboardButton("üìä  ô·¥è·¥õ s·¥õ·¥Ä·¥õs", callback_data='bot_stats')],
                [InlineKeyboardButton("‚ÑπÔ∏è  ú·¥á ü·¥ò", callback_data='help')]
            ]
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Check if update has message or callback_query
            if update.message:
                await update.message.reply_text(welcome_msg, reply_markup=reply_markup)
            elif update.callback_query:
                await update.callback_query.edit_message_text(welcome_msg, reply_markup=reply_markup)
            else:
                # Fallback
                await context.bot.send_message(
                    chat_id=update.effective_chat.id,
                    text=welcome_msg,
                    reply_markup=reply_markup
                )
            
        except Exception as e:
            logger.error(f"Start command error: {e}")
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=self.apply_small_caps("‚ö†Ô∏è ·¥Ä…¥ ·¥á Ä Ä·¥è Ä ·¥è·¥Ñ·¥Ñ·¥ú Ä Ä·¥á·¥Ö. ·¥ò ü·¥á·¥Äs·¥á ·¥õ Ä è /start ·¥Ä…¢·¥Ä…™…¥.")
            )
    
    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /help command"""
        help_text = self.apply_small_caps(
            "üé® *s·¥õ è ü…™s ú …¥·¥Ä·¥ç·¥á  ô·¥è·¥õ*\n\n"
            "*·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ös:*\n"
            "/start - s·¥õ·¥Ä Ä·¥õ ·¥õ ú·¥á  ô·¥è·¥õ\n"
            "/help - s ú·¥è·¥°  ú·¥á ü·¥ò\n"
            "/admin - ·¥Ä·¥Ö·¥ç…™…¥ ·¥ç·¥á…¥·¥ú\n\n"
            "* ú·¥è·¥° ·¥õ·¥è ·¥ús·¥á:*\n"
            "1. ·¥Ñ ü…™·¥Ñ·¥ã /start\n"
            "2. ·¥Ñ ú·¥è·¥ès·¥á '·¥Ñ Ä·¥á·¥Ä·¥õ·¥á s·¥õ è ü·¥á'\n"
            "3. ·¥á…¥·¥õ·¥á Ä  è·¥è·¥ú Ä …¥·¥Ä·¥ç·¥á\n"
            "4. s·¥á ü·¥á·¥Ñ·¥õ ·¥Ä ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è\n"
            "5. ·¥Ñ ü…™·¥Ñ·¥ã ·¥è…¥ ·¥Ä…¥ è s·¥õ è ü·¥á ·¥õ·¥è ·¥Ñ·¥è·¥ò è\n\n"
            "*…¥·¥è·¥õ·¥á:*\n"
            "‚Ä¢ …¥·¥Ä·¥ç·¥á ·¥ç·¥Äx 30 ·¥Ñ ú·¥Ä Ä·¥Ä·¥Ñ·¥õ·¥á Äs\n"
            "‚Ä¢ ·¥Ä ü ü s·¥õ è ü·¥ás s·¥ú·¥ò·¥ò·¥è Ä·¥õ·¥á·¥Ö ·¥è…¥ ·¥ç·¥è ô…™ ü·¥á & ·¥Ö·¥ás·¥ã·¥õ·¥è·¥ò\n"
            "‚Ä¢ …™…¥s·¥õ·¥Ä…¥·¥õ ·¥è…¥·¥á-·¥Ñ ü…™·¥Ñ·¥ã ·¥Ñ·¥è·¥ò è\n"
            "‚Ä¢ 2000+ s·¥õ è ü·¥ás ·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á"
        )
        
        await update.message.reply_text(help_text, parse_mode=ParseMode.MARKDOWN)
    
    async def admin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle /admin command"""
        user = update.effective_user
        
        if user.id not in ADMIN_IDS:
            await update.message.reply_text("‚õî ·¥Ä·¥Ñ·¥Ñ·¥áss ·¥Ö·¥á…¥…™·¥á·¥Ö.")
            return
        
        admin_text = self.apply_small_caps(
            "üëë *·¥Ä·¥Ö·¥ç…™…¥ ·¥ç·¥á…¥·¥ú*\n\n"
            "*·¥Ñ·¥è·¥ç·¥ç·¥Ä…¥·¥Ös:*\n"
            "/stats - s ú·¥è·¥°  ô·¥è·¥õ s·¥õ·¥Ä·¥õ…™s·¥õ…™·¥Ñs\n"
            "/broadcast - s·¥á…¥·¥Ö ·¥ç·¥áss·¥Ä…¢·¥á ·¥õ·¥è ·¥Ä ü ü ·¥ús·¥á Äs\n"
            "/users - s ú·¥è·¥° ·¥ús·¥á Ä  ü…™s·¥õ\n\n"
            "*…™…¥s·¥õ Ä·¥ú·¥Ñ·¥õ…™·¥è…¥s:*\n"
            "“ì·¥è Ä  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ:\n"
            "1.  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥áss·¥Ä…¢·¥á\n"
            "2. ·¥õ è·¥ò·¥á /broadcast\n"
            "·¥è Ä\n"
            "·¥õ è·¥ò·¥á: /broadcast  è·¥è·¥ú Ä ·¥ç·¥áss·¥Ä…¢·¥á"
        )
        
        keyboard = [
            [InlineKeyboardButton("üìä s·¥õ·¥Ä·¥õs", callback_data='admin_stats')],
            [InlineKeyboardButton("üì¢  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ", callback_data='admin_broadcast')],
            [InlineKeyboardButton("üë• ·¥ús·¥á Äs", callback_data='admin_users')],
            [InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await update.message.reply_text(admin_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    
    async def ask_for_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Ask for name"""
        query = update.callback_query
        await query.answer()
        
        await query.edit_message_text(
            self.apply_small_caps("‚úçÔ∏è ·¥ò ü·¥á·¥Äs·¥á ·¥á…¥·¥õ·¥á Ä  è·¥è·¥ú Ä …¥·¥Ä·¥ç·¥á:"),
            parse_mode=ParseMode.MARKDOWN
        )
    
    async def process_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Process name input"""
        name = update.message.text.strip()
        
        if len(name) > MAX_NAME_LENGTH:
            await update.message.reply_text(
                self.apply_small_caps(f"‚ö†Ô∏è …¥·¥Ä·¥ç·¥á ·¥õ·¥è·¥è  ü·¥è…¥…¢! ·¥ç·¥Äx {MAX_NAME_LENGTH} ·¥Ñ ú·¥Ä Äs.")
            )
            return
        
        if not name:
            await update.message.reply_text(self.apply_small_caps("‚ö†Ô∏è ·¥á…¥·¥õ·¥á Ä ·¥Ä ·¥†·¥Ä ü…™·¥Ö …¥·¥Ä·¥ç·¥á."))
            return
        
        context.user_data['name'] = name
        
        keyboard = [
            [InlineKeyboardButton("üé≠ ·¥Ö·¥á·¥Ñ·¥è Ä·¥Ä·¥õ…™·¥†·¥á (1000+)", callback_data='cat_decorative')],
            [InlineKeyboardButton("üî§ “ì·¥è…¥·¥õs (50+)", callback_data='cat_fonts')],
            [InlineKeyboardButton("üé® ·¥Ä Ä·¥õ (500+)", callback_data='cat_art')],
            [InlineKeyboardButton("üåÄ ·¥ç…™x·¥á·¥Ö (500+)", callback_data='cat_mixed')],
            [InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await update.message.reply_text(
            self.apply_small_caps(f"‚úÖ …¥·¥Ä·¥ç·¥á: `{name}`\n\nüëá s·¥á ü·¥á·¥Ñ·¥õ ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è:"),
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    
    async def show_category_styles(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show styles for category"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        name = context.user_data.get('name', '')
        
        if not name:
            await query.edit_message_text(self.apply_small_caps("‚ö†Ô∏è …¥·¥è …¥·¥Ä·¥ç·¥á “ì·¥è·¥ú…¥·¥Ö."))
            return
        
        category_map = {
            'cat_decorative': ('decorative', FontStyles.DECORATIVE_STYLES),
            'cat_fonts': ('fonts', list(FontStyles.FONTS.keys())),
            'cat_art': ('art', FontStyles.ART_STYLES),
            'cat_mixed': ('mixed', FontStyles.MIXED_STYLES)
        }
        
        if data not in category_map:
            return
        
        category, styles = category_map[data]
        context.user_data['current_category'] = category
        context.user_data['current_styles'] = styles
        context.user_data['current_page'] = 1
        
        await self.show_styles_page(update, context)
    
    async def show_styles_page(self, update: Update, context: ContextTypes.DEFAULT_TYPE, page: int = 1):
        """Show styles page"""
        query = update.callback_query if hasattr(update, 'callback_query') else None
        if query:
            await query.answer()
        
        name = context.user_data.get('name', '')
        category = context.user_data.get('current_category', '')
        styles = context.user_data.get('current_styles', [])
        
        if not name:
            return await self.start_command(update, context)
        
        if page:
            context.user_data['current_page'] = page
        else:
            page = context.user_data.get('current_page', 1)
        
        total = len(styles)
        total_pages = max(1, (total + ITEMS_PER_PAGE - 1) // ITEMS_PER_PAGE)
        page = max(1, min(page, total_pages))
        
        start = (page - 1) * ITEMS_PER_PAGE
        end = start + ITEMS_PER_PAGE
        page_styles = styles[start:end]
        
        # Generate buttons
        buttons = []
        for i, style in enumerate(page_styles, 1):
            styled_text = self._generate_styled_text(name, category, style)
            text_hash = TextStorage.store_text(styled_text)
            
            btn_text = f"{i}. {styled_text[:15]}..." if len(styled_text) > 15 else f"{i}. {styled_text}"
            buttons.append([InlineKeyboardButton(btn_text, callback_data=f"copy_{text_hash}")])
        
        # Pagination
        pagination_buttons = []
        if page > 1:
            pagination_buttons.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"page_{page-1}"))
        
        pagination_buttons.append(InlineKeyboardButton(f"{page}/{total_pages}", callback_data='current_page'))
        
        if page < total_pages:
            pagination_buttons.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"page_{page+1}"))
        
        if pagination_buttons:
            buttons.append(pagination_buttons)
        
        # Navigation
        nav_buttons = [
            InlineKeyboardButton("üîÑ ·¥Ñ ú·¥Ä…¥…¢·¥á", callback_data='change_category'),
            InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start'),
            InlineKeyboardButton("‚úèÔ∏è …¥·¥á·¥°", callback_data='new_name')
        ]
        buttons.append(nav_buttons)
        
        reply_markup = InlineKeyboardMarkup(buttons)
        
        category_names = {
            'decorative': "üé≠ ·¥Ö·¥á·¥Ñ·¥è Ä·¥Ä·¥õ…™·¥†·¥á",
            'fonts': "üî§ “ì·¥è…¥·¥õs",
            'art': "üé® ·¥Ä Ä·¥õ",
            'mixed': "üåÄ ·¥ç…™x·¥á·¥Ö"
        }
        
        category_display = category_names.get(category, category)
        
        message_text = self.apply_small_caps(
            f"üìù …¥·¥Ä·¥ç·¥á: `{name}`\n"
            f"üìÇ ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è: {category_display}\n"
            f"üìä ·¥õ·¥è·¥õ·¥Ä ü: {total}\n"
            f"üìÑ ·¥ò·¥Ä…¢·¥á: {page}/{total_pages}\n\n"
            "üëá ·¥Ñ ü…™·¥Ñ·¥ã ·¥õ·¥è ·¥Ñ·¥è·¥ò è:"
        )
        
        if query:
            await query.edit_message_text(message_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
        else:
            await context.bot.send_message(
                chat_id=update.effective_chat.id,
                text=message_text,
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
    
    def _generate_styled_text(self, name: str, category: str, style) -> str:
        """Generate styled text"""
        if category == 'fonts':
            return FontStyles.apply_font(name, style)
        elif category == 'decorative':
            return style.format(name)
        elif category == 'art':
            return style.format(name)
        elif category == 'mixed':
            font_name, decor = style
            font_text = FontStyles.apply_font(name, font_name)
            return decor.format(font_text)
        return name
    
    async def handle_pagination(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle pagination"""
        query = update.callback_query
        data = query.data
        
        if data.startswith('page_'):
            page = int(data.split('_')[1])
            await self.show_styles_page(update, context, page)
    
    async def copy_text(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Copy text handler"""
        query = update.callback_query
        data = query.data
        
        if data.startswith('copy_'):
            text_hash = data[5:]
            text_to_copy = TextStorage.get_text(text_hash)
            
            if text_to_copy:
                # Save to database in background
                user_id = query.from_user.id
                name = context.user_data.get('name', '')
                category = context.user_data.get('current_category', '')
                
                await asyncio.get_event_loop().run_in_executor(
                    None, Database.save_style, user_id, name, text_to_copy, category
                )
                
                # Send copy-able text
                await context.bot.send_message(
                    chat_id=query.message.chat_id,
                    text=f"```\n{text_to_copy}\n```",
                    parse_mode=ParseMode.MARKDOWN_V2
                )
                
                await query.answer(self.apply_small_caps("‚úÖ ·¥Ñ·¥è·¥ò…™·¥á·¥Ö!"), show_alert=True)
            else:
                await query.answer(self.apply_small_caps("‚ö†Ô∏è ·¥õ·¥áx·¥õ …¥·¥è·¥õ “ì·¥è·¥ú…¥·¥Ö"), show_alert=True)
    
    async def generate_random_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Generate random names"""
        query = update.callback_query
        await query.answer()
        
        first_parts = ["Shadow", "Dark", "Neo", "Royal", "Crimson", "Ghost", "Night", "Demon", 
                      "Cyber", "Steel", "Iron", "Golden", "Silver", "Phantom", "Mystic"]
        second_parts = ["Killer", "Hunter", "Rider", "Warrior", "Slayer", "Assassin", "Master", 
                       "Lord", "King", "Queen", "Prince", "Legend", "Hero", "Ninja", "Samurai"]
        
        await query.edit_message_text(self.apply_small_caps("üé≤ …¢·¥á…¥·¥á Ä·¥Ä·¥õ…™…¥…¢..."))
        
        for i in range(5):
            name = f"{random.choice(first_parts)}{random.choice(second_parts)}{random.randint(1, 99)}"
            
            categories = ['decorative', 'fonts', 'art', 'mixed']
            category = random.choice(categories)
            
            if category == 'decorative':
                style = random.choice(FontStyles.DECORATIVE_STYLES)
                styled_text = style.format(name)
            elif category == 'fonts':
                font = random.choice(list(FontStyles.FONTS.keys()))
                styled_text = FontStyles.apply_font(name, font)
            elif category == 'art':
                style = random.choice(FontStyles.ART_STYLES)
                styled_text = style.format(name)
            else:
                font = random.choice(list(FontStyles.FONTS.keys()))
                decor = random.choice(FontStyles.DECORATIVE_STYLES)
                styled_text = decor.format(FontStyles.apply_font(name, font))
            
            text_hash = TextStorage.store_text(styled_text)
            
            keyboard = [[InlineKeyboardButton("üìã ·¥Ñ·¥è·¥ò è", callback_data=f"copy_{text_hash}")]]
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            await context.bot.send_message(
                chat_id=query.message.chat_id,
                text=self.apply_small_caps(f"üé≤ …¥·¥Ä·¥ç·¥á #{i+1}:\n`{styled_text}`"),
                reply_markup=reply_markup,
                parse_mode=ParseMode.MARKDOWN
            )
        
        keyboard = [[InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=query.message.chat_id,
            text=self.apply_small_caps("‚úÖ 5  Ä·¥Ä…¥·¥Ö·¥è·¥ç …¥·¥Ä·¥ç·¥ás …¢·¥á…¥·¥á Ä·¥Ä·¥õ·¥á·¥Ö!"),
            reply_markup=reply_markup
        )
    
    async def show_bot_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show bot stats"""
        query = update.callback_query
        await query.answer()
        
        user_count = await asyncio.get_event_loop().run_in_executor(None, Database.get_user_count)
        
        stats_text = self.apply_small_caps(
            f"üìä  ô·¥è·¥õ s·¥õ·¥Ä·¥õ…™s·¥õ…™·¥Ñs\n\n"
            f"üë• ·¥õ·¥è·¥õ·¥Ä ü ·¥ús·¥á Äs: {user_count}\n"
            f"üé® s·¥õ è ü·¥á ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä…™·¥ás: 4\n"
            f"‚ú® ·¥õ·¥è·¥õ·¥Ä ü s·¥õ è ü·¥ás: 2000+\n"
            f"‚Ä¢ ·¥Ö·¥á·¥Ñ·¥è Ä·¥Ä·¥õ…™·¥†·¥á: 1000+\n"
            f"‚Ä¢ “ì·¥è…¥·¥õs: 50+\n"
            f"‚Ä¢ ·¥Ä Ä·¥õ: 500+\n"
            f"‚Ä¢ ·¥ç…™x·¥á·¥Ö: 500+\n\n"
            f"üöÄ  ô·¥è·¥õ s·¥õ·¥Ä·¥õ·¥ús: ·¥Ä·¥Ñ·¥õ…™·¥†·¥á"
        )
        
        keyboard = [[InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(stats_text, reply_markup=reply_markup)
    
    async def handle_navigation(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Handle navigation"""
        query = update.callback_query
        data = query.data
        await query.answer()
        
        if data == 'back_to_start':
            await self.start_command(update, context)
        elif data == 'change_category':
            await self.show_category_menu(update, context)
        elif data == 'new_name':
            await self.ask_for_name(update, context)
    
    async def show_category_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Show category menu"""
        query = update.callback_query
        await query.answer()
        
        name = context.user_data.get('name', '…¥·¥è …¥·¥Ä·¥ç·¥á')
        
        keyboard = [
            [InlineKeyboardButton("üé≠ ·¥Ö·¥á·¥Ñ·¥è Ä·¥Ä·¥õ…™·¥†·¥á (1000+)", callback_data='cat_decorative')],
            [InlineKeyboardButton("üî§ “ì·¥è…¥·¥õs (50+)", callback_data='cat_fonts')],
            [InlineKeyboardButton("üé® ·¥Ä Ä·¥õ (500+)", callback_data='cat_art')],
            [InlineKeyboardButton("üåÄ ·¥ç…™x·¥á·¥Ö (500+)", callback_data='cat_mixed')],
            [InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(
            self.apply_small_caps(f"üìù …¥·¥Ä·¥ç·¥á: `{name}`\n\nüëá s·¥á ü·¥á·¥Ñ·¥õ ·¥Ñ·¥Ä·¥õ·¥á…¢·¥è Ä è:"),
            reply_markup=reply_markup,
            parse_mode=ParseMode.MARKDOWN
        )
    
    # Admin handlers
    async def admin_stats(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Admin stats"""
        query = update.callback_query
        await query.answer()
        
        user_count = await asyncio.get_event_loop().run_in_executor(None, Database.get_user_count)
        
        stats_text = self.apply_small_caps(
            f"üëë ·¥Ä·¥Ö·¥ç…™…¥ s·¥õ·¥Ä·¥õs\n\n"
            f"üë• ·¥õ·¥è·¥õ·¥Ä ü ·¥ús·¥á Äs: {user_count}\n"
            f"üìÖ  ô·¥è·¥õ ·¥ú·¥ò·¥õ…™·¥ç·¥á: ·¥Ä·¥Ñ·¥õ…™·¥†·¥á\n"
            f"üíæ ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á: s·¥õ è ü…™s ú_…¥·¥Ä·¥ç·¥á_ ô·¥è·¥õ.·¥Ö ô\n"
            f"‚ö° ·¥ò·¥á Ä“ì·¥è Ä·¥ç·¥Ä…¥·¥Ñ·¥á: ·¥è·¥ò·¥õ…™·¥ç…™·¥¢·¥á·¥Ö\n"
            f"üé® s·¥õ è ü·¥ás ·¥Ä·¥†·¥Ä…™ ü·¥Ä ô ü·¥á: 2000+"
        )
        
        keyboard = [
            [InlineKeyboardButton("üì¢  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ", callback_data='admin_broadcast')],
            [InlineKeyboardButton("üë• ·¥ús·¥á Ä  ü…™s·¥õ", callback_data='admin_users')],
            [InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(stats_text, reply_markup=reply_markup)
    
    async def admin_broadcast(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Admin broadcast"""
        query = update.callback_query
        await query.answer()
        
        broadcast_text = self.apply_small_caps(
            "üì¢ * ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ ·¥ç·¥á…¥·¥ú*\n\n"
            "*…™…¥s·¥õ Ä·¥ú·¥Ñ·¥õ…™·¥è…¥s:*\n"
            "·¥õ·¥è s·¥á…¥·¥Ö  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ:\n"
            "1.  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥áss·¥Ä…¢·¥á\n"
            "2. ·¥õ è·¥ò·¥á /broadcast\n"
            "\n·¥è Ä\n"
            "\n·¥õ è·¥ò·¥á: /broadcast  è·¥è·¥ú Ä ·¥ç·¥áss·¥Ä…¢·¥á\n\n"
            "*…¥·¥è·¥õ·¥á:*\n"
            "‚Ä¢ ·¥è…¥ ü è ·¥Ä·¥Ö·¥ç…™…¥s ·¥Ñ·¥Ä…¥  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ\n"
            "‚Ä¢ ·¥ús·¥á ·¥°…™s·¥á ü è\n"
            "‚Ä¢ ·¥Ö·¥è…¥'·¥õ s·¥ò·¥Ä·¥ç"
        )
        
        keyboard = [
            [InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')],
            [InlineKeyboardButton("üìä s·¥õ·¥Ä·¥õs", callback_data='admin_stats')]
        ]
        
        reply_markup = InlineKeyboardMarkup(keyboard)
        await query.edit_message_text(broadcast_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)
    
    async def admin_users(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """Admin users"""
        query = update.callback_query
        await query.answer()
        
        users = await asyncio.get_event_loop().run_in_executor(None, Database.get_all_users)
        
        if not users:
            await query.edit_message_text(self.apply_small_caps("üì≠ …¥·¥è ·¥ús·¥á Äs “ì·¥è·¥ú…¥·¥Ö."))
            return
        
        users_text = self.apply_small_caps(f"üë• ·¥õ·¥è·¥õ·¥Ä ü ·¥ús·¥á Äs: {len(users)}\n\n")
        
        for i, user_id in enumerate(users[:10], 1):
            users_text += f"{i}. `{user_id}`\n"
        
        if len(users) > 10:
            users_text += f"\n... ·¥Ä…¥·¥Ö {len(users) - 10} ·¥ç·¥è Ä·¥á\n"
        
        keyboard = [[InlineKeyboardButton("üè†  ú·¥è·¥ç·¥á", callback_data='back_to_start')]]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await query.edit_message_text(users_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)

# ==================== ADMIN COMMANDS ====================
async def stats_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /stats command"""
    if update.effective_user.id not in ADMIN_IDS:
        await update.message.reply_text("‚õî ·¥Ä·¥Ñ·¥Ñ·¥áss ·¥Ö·¥á…¥…™·¥á·¥Ö.")
        return
    
    bot_handlers = BotHandlers()
    user_count = await asyncio.get_event_loop().run_in_executor(None, Database.get_user_count)
    
    stats_text = bot_handlers.apply_small_caps(
        f"üìä  ô·¥è·¥õ s·¥õ·¥Ä·¥õ…™s·¥õ…™·¥Ñs\n\n"
        f"üë• ·¥õ·¥è·¥õ·¥Ä ü ·¥ús·¥á Äs: {user_count}\n"
        f"‚ö°  ô·¥è·¥õ s·¥õ·¥Ä·¥õ·¥ús: ·¥Ä·¥Ñ·¥õ…™·¥†·¥á\n"
        f"üíæ ·¥Ö·¥Ä·¥õ·¥Ä ô·¥Äs·¥á: ·¥è·¥ò·¥á Ä·¥Ä·¥õ…™·¥è…¥·¥Ä ü\n"
        f"üé® s·¥õ è ü·¥ás: 2000+\n"
        f"üöÄ ·¥ò·¥á Ä“ì·¥è Ä·¥ç·¥Ä…¥·¥Ñ·¥á: ·¥è·¥ò·¥õ…™·¥ç…™·¥¢·¥á·¥Ö"
    )
    
    await update.message.reply_text(stats_text)

async def broadcast_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Handle /broadcast command"""
    if update.effective_user.id not in ADMIN_IDS:
        await update.message.reply_text("‚õî ·¥Ä·¥Ñ·¥Ñ·¥áss ·¥Ö·¥á…¥…™·¥á·¥Ö.")
        return
    
    # Check if replying to message
    if update.message.reply_to_message:
        message = update.message.reply_to_message.text or update.message.reply_to_message.caption
        if not message:
            await update.message.reply_text("‚ö†Ô∏è …¥·¥è ·¥õ·¥áx·¥õ …™…¥  Ä·¥á·¥ò ü…™·¥á·¥Ö ·¥ç·¥áss·¥Ä…¢·¥á.")
            return
    elif context.args:
        message = " ".join(context.args)
    else:
        await update.message.reply_text("‚ö†Ô∏è ·¥ús·¥Ä…¢·¥á: /broadcast <·¥ç·¥áss·¥Ä…¢·¥á> ·¥è Ä  Ä·¥á·¥ò ü è ·¥õ·¥è ·¥Ä ·¥ç·¥áss·¥Ä…¢·¥á.")
        return
    
    users = await asyncio.get_event_loop().run_in_executor(None, Database.get_all_users)
    total = len(users)
    
    if total == 0:
        await update.message.reply_text("üì≠ …¥·¥è ·¥ús·¥á Äs ·¥õ·¥è  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ ·¥õ·¥è.")
        return
    
    await update.message.reply_text(f"üì¢  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ…™…¥…¢ ·¥õ·¥è {total} ·¥ús·¥á Äs...")
    
    success = 0
    failed = 0
    
    bot_handlers = BotHandlers()
    broadcast_msg = f"üì¢ * ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ:*\n\n{message}"
    
    for user_id in users:
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text=broadcast_msg,
                parse_mode=ParseMode.MARKDOWN
            )
            success += 1
            await asyncio.sleep(0.1)
        except Exception as e:
            logger.error(f"“ì·¥Ä…™ ü·¥á·¥Ö ·¥õ·¥è s·¥á…¥·¥Ö ·¥õ·¥è {user_id}: {e}")
            failed += 1
    
    result_text = bot_handlers.apply_small_caps(
        f"‚úÖ  ô Ä·¥è·¥Ä·¥Ö·¥Ñ·¥Äs·¥õ ·¥Ñ·¥è·¥ç·¥ò ü·¥á·¥õ·¥á!\n"
        f"‚úì s·¥ú·¥Ñ·¥Ñ·¥áss: {success}\n"
        f"‚úó “ì·¥Ä…™ ü·¥á·¥Ö: {failed}\n"
        f"üìä ·¥õ·¥è·¥õ·¥Ä ü: {total}"
    )
    
    await update.message.reply_text(result_text)

# ==================== ERROR HANDLER ====================
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE):
    """Handle errors"""
    error_msg = str(context.error) if context.error else "Unknown error"
    logger.error(f"·¥á Ä Ä·¥è Ä: {error_msg}")

# ==================== MAIN FUNCTION ====================
def main():
    """Main function"""
    try:
        # Initialize database
        Database.setup()
        
        # Create bot
        bot_handlers = BotHandlers()
        
        # Create application
        persistence = PicklePersistence(filepath="bot_persistence")
        application = Application.builder().token(BOT_TOKEN).persistence(persistence).build()
        
        # Add error handler
        application.add_error_handler(error_handler)
        
        # Add command handlers
        application.add_handler(CommandHandler("start", bot_handlers.start_command))
        application.add_handler(CommandHandler("help", bot_handlers.help_command))
        application.add_handler(CommandHandler("admin", bot_handlers.admin_command))
        application.add_handler(CommandHandler("stats", stats_command))
        application.add_handler(CommandHandler("broadcast", broadcast_command))
        
        # Add callback query handlers
        application.add_handler(CallbackQueryHandler(bot_handlers.ask_for_name, pattern='^create_style$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.generate_random_name, pattern='^random_name$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.show_bot_stats, pattern='^bot_stats$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.help_command, pattern='^help$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.show_category_styles, pattern='^cat_'))
        application.add_handler(CallbackQueryHandler(bot_handlers.handle_pagination, pattern='^page_'))
        application.add_handler(CallbackQueryHandler(bot_handlers.copy_text, pattern='^copy_'))
        application.add_handler(CallbackQueryHandler(bot_handlers.handle_navigation, pattern='^(back_to_start|new_name|change_category)$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.admin_stats, pattern='^admin_stats$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.admin_broadcast, pattern='^admin_broadcast$'))
        application.add_handler(CallbackQueryHandler(bot_handlers.admin_users, pattern='^admin_users$'))
        
        # Add message handler
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, bot_handlers.process_name))
        
        # Start bot
        logger.info("üöÄ s·¥õ è ü…™s ú …¥·¥Ä·¥ç·¥á  ô·¥è·¥õ …™s s·¥õ·¥Ä Ä·¥õ…™…¥…¢...")
        application.run_polling(
            allowed_updates=Update.ALL_TYPES,
            poll_interval=0.5,
            drop_pending_updates=True
        )
        
    except Exception as e:
        logger.error(f"“ì·¥Ä·¥õ·¥Ä ü ·¥á Ä Ä·¥è Ä: {e}")

if __name__ == '__main__':
    main()